options("scipen"=999,"digits"=4)
 
REx_ANA_PLOT <- function(w=500,h=500) {
  ## save plot as temp file
  REx.plot.tempfn <<- paste(tempdir(), "\\REx_temp.png", sep="")
  png(filename=REx.plot.tempfn, width=w, height=h)
}

REx_ANA_PLOT_OFF <- function(caption) {
  dev.off()
  load.pkg("markdown")
  ## read temp file as a binary string
  img <- paste(markdown:::.b64EncodeFile(REx.plot.tempfn))
  R2HTML::HTML(paste("<p align=left><img src='", img, "' /><br /><font class=caption>", caption, "</font></p>", sep=""),file="./test.html")
}

local.install.packages <- function(pkgs, repos, type='win.binary') {
	rversion = paste(R.version$major, strsplit(R.version$minor, '.', fixed=TRUE)[[1]][1], sep='.')
	local.contriburl = contrib.url(paste('file:///', repos, sep=''), type=type)
	local.pkgs = available.packages(local.contriburl)

	dir = '/src/contrib/'
	extension = '.tar.gz'
	if(type == 'mac.binary.leopard' | type == 'mac.binary') {
		dir = paste('/bin/macosx/leopard/contrib/', rversion, '/', sep='')
		extension = '.tgz'
	} else if(type == 'win.binary') {
		dir = paste('/bin/windows/contrib/', rversion, '/', sep='')
		extension = '.zip'
	}
	installed = installed.packages()
	#package.dependencies(local.pkgs[local.pkgs[,'Package'] %in% pkgs,])
	
	d = c("Depends", "Imports", "LinkingTo", "Suggests", "Enhances")
	toinstall = utils:::getDependencies(pkgs, d, local.pkgs)
	ininstall2 = utils:::getDependencies(toinstall, d, local.pkgs)
	while(length(toinstall) != length(ininstall2)) {
		toinstall = ininstall2
		ininstall2 = utils:::getDependencies(toinstall, d, local.pkgs)		
	}
	
	for(i in 1:length(toinstall)) {
		toinstall[i] = paste(repos, dir,
				 toinstall[i], '_', 
				 local.pkgs[local.pkgs[,'Package'] == toinstall[i],'Version'], 
				 extension,
				 sep='')
	}
	print('Install the following packages:')
	print(toinstall)
	install.packages(toinstall, repos=NULL, contrib.url=local.contriburl, available=local.pkgs, type=type)
}

inst.pkg <- function(pkg, repos="http://healthstat.snu.ac.kr/CRAN") {
	if (!suppressWarnings(require(pkg, quietly=TRUE, character.only=TRUE))) {
		ret <- try(local.install.packages(pkg, repos=repos), T)
		if (class(ret) == 'try-error') 2
		else 1
	}
	0
}

load.pkg <- function(pkgs) {
  for (i in pkgs) {
    ret <- inst.pkg(i)
	if (ret != 0) {
	  if (ret == 2) stop(paste0("패키지 [", i, "] 설치에 실패했습니다. Rex 개발팀에게 문의해 주세요!"))
	  else if (ret == 1) {
	    if (class(require(i, quietly=TRUE, character.only=TRUE)) == 'try-error')
		  stop(paste0("패키지 [", i, "] 가 설치되었지만 로드에 실패했습니다. Rex 개발팀에게 문의해 주세요!"))
	  }
	}
  }
}

# Function for formatting numbers
Digits <- function(x) {
	x1 <- x
	if(!is.vector(x)){
		# all NA
		allNA <- apply(x,2,function(gg) all(is.na(gg)))
		x <- x[,!allNA,drop=F]
	}

	if(length(x)!=0){
		x[abs(x)>=0.0001&!is.na(x)] <- round(x[abs(x)>0.0001&!is.na(x)],4)
		w.xx <- abs(x)<0.0001&!is.na(x)&x!=0; xx = x[w.xx]
		w.xxx <- abs(x)>=1e15&!is.na(x); xxx = x[w.xxx]
		if(length(xx)>0){
			x[w.xx] <- paste0(gsub('e','x10<sup>',format(xx,scientific=T,digits=4)),'</sup>')
		}
		if(length(xxx)>0){
			x[w.xxx] <- paste0(gsub('e\\+','x10<sup>',format(xxx,scientific=T,digits=4)),'</sup>')
		}
		x[x==0] <- '0'
		if(!is.vector(x)) {
			x1[,!allNA] <- x
		} else {
			x1 <- x
		}
	}
	x1[is.na(x1)] <- ""
	return(x1)
}

# Package List
indiv.pkg.info <- function(pkg.info) {
	funs <- strsplit(pkg.info[[2]],",\\s*")[[1]]
	paste0("<li> ",pkg.info[[1]]," : ",
	paste0(paste0(paste0("function ",
		paste(sapply(funs,function(v)paste0("'<a href=\"https://www.rdocumentation.org/packages/", pkg.info[[3]], "/topics/", v, "\" target='_new'>", v, "</a>'")),collapse=", "),
		" of R package '"),"<a href=\"https://www.rdocumentation.org/packages/", pkg.info[[3]], "\" target='_new'>", pkg.info[[3]],"</a>'"),collapse=", "))
}
used.pkg <- function(pkg.list) paste(c(sapply(pkg.list,indiv.pkg.info),"<li> All results other than those mentioned above were written with basic functions of R."),collapse=" <br> ")

# Check integer
check.integer <- function(x) x == round(x)

# Variable selection
stepAIC.wj <- function(object,dataset,dep_var=NULL,type=c('lm','wlm','binom','multinom','poisson','coxph'),
		       noint,direct,keep_var,hr,vars,WTS=NULL,link=NULL,res_type=NULL,dist=NULL,baseline=NULL,
		       tmp.parallel=NULL,offset=NULL,time1=NULL,event=NULL,
		       CI=FALSE, confint.level=0.95, VIF=FALSE,VIP=FALSE,odds=FALSE,exp_estim=FALSE,printlevel=NULL,norm.parallel=FALSE,ord.parallel=FALSE,expestim=FALSE) {

	R2HTML::HTML(R2HTML::as.title("Variable Selection"),HR=hr,file="./test.html")

	# Process of VS
	R2HTML::HTML(R2HTML::as.title("Process of Variable Selection"),HR=hr+1,file="./test.html",append=TRUE)
	cap <- "<div style='text-align:left'><li> Note : Models that failed to fit are excluded from the results. <br><li> Note : AICs are omitted for the models where log-likelihood is not calculated."

	#browser()
	if(direct=="forward"){
		predictor <- ifelse(is.null(keep_var),1,paste(keep_var,collapse='+'))
		if(noint){
			if(is.null(keep_var)){
				getIM <- function(v){
					form.temp <- paste(dep_var,'~',v,'-1')
					if(type=='lm') fit.temp <- lm(as.formula(form.temp),data=dataset)
					if(type=='wlm') fit.temp <- lm(as.formula(form.temp),data=dataset,weight=WTS)
					if(type=='binom') {
						command_str <- paste0("fit.temp <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='multinom'){
						if (res_type == "nominal") {
							fit.temp <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
						} else {
							command_str	<- paste0("try(fit.temp <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
							suppressWarnings(eval(parse(text=command_str)))
						}
					}
					if(type=='poisson'){
						command_str <- paste0("fit.temp <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='coxph') {
						form.temp <- paste0("Surv(dataset[,time1], dataset[,event]) ~ ",v)
						fm <- formula(form.temp)
						fit.temp <- survival::coxph(fm, data=dataset)
					}
					return(data.frame(Model=form.temp,AIC=AIC(fit.temp)))
				}
				comp <- do.call(rbind,lapply(vars,getIM))
				comp[,1] <- as.character(comp[,1])
				form.temp <- comp[comp[,2]==min(comp[,2]),1]
				if(type=='lm') fit.lower <- lm(as.formula(form.temp),data=dataset)
				if(type=='wlm') fit.lower <- lm(as.formula(form.temp),data=dataset,weight=WTS)
				if(type=='binom') {
					command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
					eval(parse(text=command_str))
				}
				if(type=='multinom'){
					if (res_type == "nominal") {
						fit.lower <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
					} else {
						command_str	<- paste0("try(fit.lower <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
						suppressWarnings(eval(parse(text=command_str)))
					}
				}
				if(type=='poisson'){
					command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
					eval(parse(text=command_str))
				}
				if(type=='coxph') {
					fm <- formula(form.temp)
					fit.lower <- survival::coxph(fm, data=dataset)
				}
				predictor <- paste(vars[comp[,2]==min(comp[,2])],'-1')
				comp[,1] <- gsub('-1','(Intercept is not included)',comp[,1])
				comp <- comp[order(comp[,2]),]
				comp[,-1] <- Digits(comp[,-1])
				if(type=='coxph'){
					comp[,1] <- gsub("Surv.*\\)","Hazard ratio",comp[,1])
					comp[,1] <- paste0(gsub("~ ","~ exp(",comp[,1]),")")
				}
				R2HTML::HTML(R2HTML::as.title('Step 0 : Initial model (Smaller AIC values are better)'),HR=hr+2,file="./test.html",append=TRUE)
				R2HTML::HTML(comp,file="./test.html",align="left",row.names=F,digits=15)
			} else {
				predictor <- paste(predictor,'-1')
				form.temp <- paste0(dep_var,'~',predictor)

				if(type=='lm') fit.lower <- lm(as.formula(form.temp),data=dataset)
				if(type=='wlm') fit.lower <- lm(as.formula(form.temp),data=dataset,weight=WTS)
				if(type=='binom') {
					command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
					eval(parse(text=command_str))
				}
				if(type=='multinom'){
					if (res_type == "nominal") {
						fit.lower <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
					} else {
						command_str	<- paste0("try(fit.lower <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
						suppressWarnings(eval(parse(text=command_str)))
					}
				}
				if(type=='poisson'){
					command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
					eval(parse(text=command_str))
				}
				if(type=='coxph') {
					form.temp <- paste0("Surv(dataset[,time1], dataset[,event]) ~ ",predictor)
					fm <- formula(form.temp)
					fit.lower <- survival::coxph(fm, data=dataset)
				}
			}
		} else {
			form.temp <- paste0(dep_var,'~',predictor)

			if(type=='lm') fit.lower <- lm(as.formula(form.temp),data=dataset)
			if(type=='wlm') fit.lower <- lm(as.formula(form.temp),data=dataset,weight=WTS)
			if(type=='binom') {
				command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
				eval(parse(text=command_str))
			}
			if(type=='multinom'){
				if (res_type == "nominal") {
					fit.lower <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
				} else {
					command_str	<- paste0("try(fit.lower <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
					suppressWarnings(eval(parse(text=command_str)))
				}
			}
			if(type=='poisson'){
				command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
				eval(parse(text=command_str))
			}
		}

		AICtable <- list()
		currAIC <- currModel <- c()
		j=0
		while(1){
			j=j+1
			add.vars <- vars[!vars%in%unlist(strsplit(as.character(predictor),"\\+| "))]
			AIC.table <- data.frame(term='none',DF=as.numeric(NA),AIC=AIC(fit.lower))
			currAIC <- c(currAIC,AIC(fit.lower))
			if(type=='coxph'){
				currModel <- c(currModel,paste0('Hazard ratio ~ exp(',ifelse(predictor==1,'(Intercept)',gsub(' -1','',predictor)),')'))

			} else {
				currModel <- c(currModel,paste(dep_var,'~',ifelse(predictor==1,'(Intercept)',predictor)))
			}
			jjj=1
			all.fit <- list(fit.lower)
			if(length(add.vars)!=0) {
				for(jj in add.vars){
					new.predictor <- paste(predictor,'+',jj)
					form.temp <- paste(dep_var,'~',new.predictor)

					if(type=='lm') fit.upper <- lm(as.formula(form.temp),data=dataset)
					if(type=='wlm') fit.upper <- lm(as.formula(form.temp),data=dataset,weight=WTS)
					if(type=='binom') {
						command_str <- paste0("fit.upper <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='multinom'){
						if (res_type == "nominal") {
							fit.upper <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
						} else {
							command_str	<- paste0("try(fit.upper <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
							suppressWarnings(eval(parse(text=command_str)))
						}
					}
					if(type=='poisson'){
						command_str <- paste0("fit.upper <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='coxph') {
						form.temp <- paste0("Surv(dataset[,time1], dataset[,event]) ~ ",gsub("-1","",new.predictor))
						fm <- formula(form.temp)
						fit.upper <- survival::coxph(fm, data=dataset)
					}

					if(!'try-error'%in%class(fit.upper)){
						DF <- ifelse(type%in%c('lm','wlm','binom','poisson'),fit.lower$df.residual-fit.upper$df.residual,ifelse(type=='multinom',fit.lower@df.residual-fit.upper@df.residual,length(fit.upper$coef)-length(fit.lower$coef)))
						tmp.AIC.table <- data.frame(term=paste('+',jj),DF=DF,AIC=AIC(fit.upper))
						AIC.table <- rbind(AIC.table,tmp.AIC.table)
						jjj=jjj+1
						all.fit[[jjj]] <- fit.upper
					}
				}
			}
			Best <- temp.best <- which(AIC.table$AIC==min(AIC.table$AIC,na.rm=TRUE))
			if(length(Best)>1) {
				if(1%in%Best) {
					Best <- 1
				} else {
					temp.df <- AIC.table[Best,2]
					min.df <- Best[temp.df==min(temp.df,na.rm=T)]
					if(length(min.df)==1){
						Best <- min.df
					} else {
						Best <- sample(Best,1)
					}
				}
				temp.best <- c(Best,temp.best[!temp.best==Best])
			}
			fit.lower <- all.fit[[Best]]
			AIC.table <- AIC.table[order(AIC.table$AIC),]
			AIC.table[,-1] <- Digits(AIC.table[,-1]) 
			new.rn <- row.names(AIC.table)
			new.rn[1:length(temp.best)] <- temp.best
			AIC.table <- AIC.table[new.rn,]
			AICtable[[j]] <- AIC.table
			if(AIC.table[1,1]=='none') {
				break
			} else {
				if(is.null(keep_var)&j==1) {
					predictor <- add.vars[as.numeric(row.names(AIC.table)[1])-1]
				} else {
					predictor <- paste(predictor,'+',add.vars[as.numeric(row.names(AIC.table)[1])-1])
				}
			}
		}
		if(noint & type!='coxph') {currModel <- paste(gsub(' -1','',currModel),'(Intercept is not included)')}
		for(j in seq(length(currAIC))){
			Title <- ifelse(j==length(currAIC),paste0("Step ",j," (Final)"),paste0("Step ",j))
			R2HTML::HTML(R2HTML::as.title(Title),HR=hr+2,file="./test.html",append=TRUE)
			R2HTML::HTML(paste0("AIC=",Digits(currAIC[j])),file="./test.html",align="left")
			R2HTML::HTML(currModel[j],file="./test.html",align="left")
			if(j==length(currAIC)) {
				R2HTML::HTML(AICtable[[j]],file="./test.html",align="left",row.names=F,digits=15,caption=cap)
			} else {
				R2HTML::HTML(AICtable[[j]],file="./test.html",align="left",row.names=F,digits=15)
			}
		}
	 } else if (direct=='backward') {
		tmp.vars <- vars
		fit.upper <- object
		AICtable <- list()
		currAIC <- currModel <- c()
		j=0
		while(1){
			j=j+1
			rm.vars <- tmp.vars[!tmp.vars%in%keep_var]
			if(noint & length(tmp.vars)==1) rm.vars <- character(0)
			AIC.table <- data.frame(term='none',DF=as.numeric(NA),AIC=AIC(fit.upper))
			currAIC <- c(currAIC,AIC(fit.upper))
			if(type=='coxph'){
				currModel <- c(currModel,paste0('Hazard ratio ~ exp(',paste0(paste(tmp.vars,collapse='+')),')'))

			} else {
				currModel <- c(currModel,paste(dep_var,'~',paste(tmp.vars,collapse='+'),ifelse(noint,'-1','')))
			}
			
			jjj=1
			all.fit <- list(fit.upper)
			if(length(rm.vars)!=0){
				for(jj in rm.vars){
					new.predictor <- ifelse(length(tmp.vars[!tmp.vars%in%jj])==0,1,paste(tmp.vars[!tmp.vars%in%jj],collapse='+'))
					new.predictor <- paste(new.predictor,ifelse(noint,'-1',''))
					form.temp <- paste(dep_var,'~',new.predictor)
					
					if(type=='lm') fit.lower <- lm(as.formula(form.temp),data=dataset)
					if(type=='wlm') fit.lower <- lm(as.formula(form.temp),data=dataset,weight=WTS)
					if(type=='binom') {
						command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='multinom'){
						if (res_type == "nominal") {
							fit.lower <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
						} else {
							command_str	<- paste0("try(fit.lower <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
							suppressWarnings(eval(parse(text=command_str)))
						}
					}
					if(type=='poisson'){
						command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='coxph') {
						form.temp <- paste0("Surv(dataset[,time1], dataset[,event]) ~ ",gsub("-1","",new.predictor))
						fm <- formula(form.temp)
						fit.lower <- survival::coxph(fm, data=dataset)
					}
					
					if(!'try-error'%in%class(fit.lower)){
						DF <- ifelse(type%in%c('lm','wlm','binom','poisson'),fit.lower$df.residual-fit.upper$df.residual,ifelse(type=='multinom',fit.lower@df.residual-fit.upper@df.residual,length(fit.upper$coef)-length(fit.lower$coef)))
						tmp.AIC.table <- data.frame(term=paste('-',jj),DF=DF,AIC=AIC(fit.lower))
						AIC.table <- rbind(AIC.table,tmp.AIC.table)
						jjj=jjj+1
						all.fit[[jjj]] <- fit.lower
					}
				}
			}
			Best <- temp.best <- which(AIC.table$AIC==min(AIC.table$AIC,na.rm=TRUE))
			if(length(Best)>1) {
				if(1%in%Best) {
					Best <- 1
				} else {
					temp.df <- AIC.table[Best,2]
					min.df <- Best[temp.df==min(temp.df,na.rm=T)]
					if(length(min.df)==1){
						Best <- min.df
					} else {
						Best <- sample(Best,1)
					}
				}
				temp.best <- c(Best,temp.best[!temp.best==Best])
			}
			fit.upper <- all.fit[[Best]]
			AIC.table <- AIC.table[order(AIC.table$AIC),]
			AIC.table[,-1] <- Digits(AIC.table[,-1]) 
			new.rn <- row.names(AIC.table)
			new.rn[1:length(temp.best)] <- temp.best
			AIC.table <- AIC.table[new.rn,]
			AICtable[[j]] <- AIC.table
			if(AIC.table[1,1]=='none') {
				break
			} else {
				tmp.vars <- tmp.vars[!tmp.vars%in%rm.vars[as.numeric(row.names(AIC.table)[1])-1]]
				if(length(tmp.vars)==0){
					if(!noint){
						j=j+1
						currAIC <- c(currAIC,AIC(fit.upper))
						currModel <- c(currModel,paste(dep_var,'~ (Intercept)'))
						AIC.table <- data.frame(term='none',DF=as.numeric(NA),AIC=AIC(fit.upper))
						AIC.table[,-1] <- Digits(AIC.table[,-1])
						AICtable[[j]] <- AIC.table
					}
					break
				}
			}
		}
		if(noint & type!='coxph') {currModel <- paste(gsub(' -1','',currModel),'(Intercept is not included)')}
		for(j in seq(length(currAIC))){
			Title <- ifelse(j==length(currAIC),paste0("Step ",j," (Final)"),paste0("Step ",j))
			R2HTML::HTML(R2HTML::as.title(Title),HR=hr+2,file="./test.html",append=TRUE)
			R2HTML::HTML(paste0("AIC=",Digits(currAIC[j])),file="./test.html",align="left")
			R2HTML::HTML(currModel[j],file="./test.html",align="left")
			if(j==length(currAIC)) {
				R2HTML::HTML(AICtable[[j]],file="./test.html",align="left",row.names=F,digits=15,caption=cap)
			} else {
				R2HTML::HTML(AICtable[[j]],file="./test.html",align="left",row.names=F,digits=15)
			}
		}
	 } else {
		tmp.vars <- vars
		fit.model <- object
		AICtable <- list()
		currAIC <- currModel <- c()
		j=0
		while(1){
			j=j+1
			rm.vars <- tmp.vars[!tmp.vars%in%keep_var]
			if(noint & length(tmp.vars)==1) rm.vars <- character(0)
			add.vars <- vars[!vars%in%tmp.vars]
			AIC.table <- data.frame(term='none',DF=as.numeric(NA),AIC=AIC(fit.model))
			currAIC <- c(currAIC,AIC(fit.model))
			if(type=='coxph'){
				currModel <- c(currModel,paste0('Hazard ratio ~ exp(',ifelse(length(tmp.vars)==0,'(Intercept)',paste0(paste(tmp.vars,collapse='+'))),')'))

			} else {
				currModel <- c(currModel,paste(dep_var,'~',ifelse(length(tmp.vars)==0,'(Intercept)',paste0(paste(tmp.vars,collapse='+'),ifelse(noint,' -1','')))))
			}

			jjj=1
			all.fit <- list(fit.model)
			if(length(rm.vars)!=0){
				for(jj in rm.vars){
					new.predictor <- ifelse(length(tmp.vars[!tmp.vars%in%jj])==0,1,paste0(paste(tmp.vars[!tmp.vars%in%jj],collapse='+'),ifelse(noint,' -1','')))
					form.temp <- paste(dep_var,'~',new.predictor)

					if(type=='lm') fit.lower <- lm(as.formula(form.temp),data=dataset)
					if(type=='wlm') fit.lower <- lm(as.formula(form.temp),data=dataset,weight=WTS)
					if(type=='binom') {
						command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='multinom'){
						if (res_type == "nominal") {
							fit.lower <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
						} else {
							command_str	<- paste0("try(fit.lower <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
							suppressWarnings(eval(parse(text=command_str)))
						}
					}
					if(type=='poisson'){
						command_str <- paste0("fit.lower <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='coxph') {
						form.temp <- paste0("Surv(dataset[,time1], dataset[,event]) ~ ",gsub("-1","",new.predictor))
						fm <- formula(form.temp)
						fit.lower <- survival::coxph(fm, data=dataset)
					}

					if(!'try-error'%in%class(fit.lower)){
						DF <- ifelse(type%in%c('lm','wlm','binom','poisson'),fit.lower$df.residual-fit.model$df.residual,ifelse(type=='multinom',fit.lower@df.residual-fit.model@df.residual,length(fit.model$coef)-length(fit.lower$coef)))
						tmp.AIC.table <- data.frame(term=paste('-',jj),DF=DF,AIC=AIC(fit.lower))
						AIC.table <- rbind(AIC.table,tmp.AIC.table)
						jjj=jjj+1
						all.fit[[jjj]] <- fit.lower
					}
				}
			}
			if(length(add.vars)!=0) {
				for(jj in add.vars){
					new.predictor <- ifelse(length(tmp.vars)==0,jj,paste(paste(tmp.vars,collapse='+'),'+',jj,ifelse(noint,' -1','')))
					form.temp <- paste(dep_var,'~',new.predictor)

					if(type=='lm') fit.upper <- lm(as.formula(form.temp),data=dataset)
					if(type=='wlm') fit.upper <- lm(as.formula(form.temp),data=dataset,weight=WTS)
					if(type=='binom') {
						command_str <- paste0("fit.upper <- glm(",form.temp,",data=dataset,family=binomial(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='multinom'){
						if (res_type == "nominal") {
							fit.upper <- try(suppressWarnings(VGAM::vglm(as.formula(form.temp), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
						} else {
							command_str	<- paste0("try(fit.upper <- VGAM::vglm(",form.temp,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
							suppressWarnings(eval(parse(text=command_str)))
						}
					}
					if(type=='poisson'){
						command_str <- paste0("fit.upper <- glm(",form.temp,",data=dataset,family=dist(",link,"))")
						eval(parse(text=command_str))
					}
					if(type=='coxph') {
						form.temp <- paste0("Surv(dataset[,time1], dataset[,event]) ~ ",gsub("-1","",new.predictor))
						fm <- formula(form.temp)
						fit.upper <- survival::coxph(fm, data=dataset)
					}


					if(!'try-error'%in%class(fit.upper)){
						DF <- ifelse(type%in%c('lm','wlm','binom','poisson'),fit.model$df.residual-fit.upper$df.residual,ifelse(type=='multinom',fit.model@df.residual-fit.upper@df.residual,length(fit.upper$coef)-length(fit.model$coef)))
						tmp.AIC.table <- data.frame(term=paste('+',jj),DF=DF,AIC=AIC(fit.upper))
						AIC.table <- rbind(AIC.table,tmp.AIC.table)
						jjj=jjj+1
						all.fit[[jjj]] <- fit.upper
					}
				}
			}
			Best <- temp.best <- which(AIC.table$AIC==min(AIC.table$AIC,na.rm=TRUE))
			if(length(Best)>1) {
				if(1%in%Best) {
					Best <- 1
				} else {
					temp.df <- AIC.table[Best,2]
					min.df <- Best[temp.df==min(temp.df,na.rm=T)]
					if(length(min.df)==1){
						Best <- min.df
					} else {
						Best <- sample(Best,1)
					}
				}
				temp.best <- c(Best,temp.best[!temp.best==Best])
			}
			fit.model <- all.fit[[Best]]
			AIC.table <- AIC.table[order(AIC.table$AIC),]
			AIC.table[,-1] <- Digits(AIC.table[,-1]) 
			new.rn <- row.names(AIC.table)
			new.rn[1:length(temp.best)] <- temp.best
			AIC.table <- AIC.table[new.rn,]
			AICtable[[j]] <- AIC.table
			if(AIC.table[1,1]=='none') {
				break
			} else {
				tmp.res <- strsplit(as.character(AIC.table[1,1]),' ')[[1]]
				if(tmp.res[1]=='-'){
					tmp.vars <- tmp.vars[!tmp.vars%in%tmp.res[2]]
				} else {
					tmp.vars <- c(tmp.vars,tmp.res[2])
				}
			}
		}
		if(noint & type!='coxph') {currModel <- paste(gsub(' -1','',currModel),'(Intercept is not included)')}
		for(j in seq(length(currAIC))){
			Title <- ifelse(j==length(currAIC),paste0("Step ",j," (Final)"),paste0("Step ",j))
			R2HTML::HTML(R2HTML::as.title(Title),HR=hr+2,file="./test.html",append=TRUE)
			R2HTML::HTML(paste0("AIC=",Digits(currAIC[j])),file="./test.html",align="left")
			R2HTML::HTML(currModel[j],file="./test.html",align="left")
			if(j==length(currAIC)) {
				R2HTML::HTML(AICtable[[j]],file="./test.html",align="left",row.names=F,digits=15,caption=cap)
			} else {
				R2HTML::HTML(AICtable[[j]],file="./test.html",align="left",row.names=F,digits=15)
			}
		}
	}

	# Result of VS
	R2HTML::HTML(R2HTML::as.title("Result of Variable Selection"),HR=hr+1,file="./test.html")
	resVS <- data.frame(Model=currModel[c(1,length(currModel))])
	row.names(resVS) <- c('Initial Model','Final Model')
	R2HTML::HTML(resVS,file="./test.html",align="left")

	R2HTML::HTML(R2HTML::as.title("Coefficient Estimates of the Final Model"),HR=hr+1,file="./test.html")
	final.predictor <- gsub('\\(Intercept\\)','1',gsub('\\(Intercept is not included\\)','-1',gsub("^.+ ~ ","",currModel[length(currModel)])))
	form.final <- paste(dep_var,'~',final.predictor)

	if(type=='lm') {
		fit.final <- lm(as.formula(form.final),data=dataset)
		CE <- summary(fit.final)$coef
		if(CI){
			tmp <- merge(CE,confint(fit.final, level=confint.level),by="row.names",all=TRUE,sort=F)
			rownames(tmp) <- tmp[,1]
			CE <- tmp[,-1]
			colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of ',confint.level*100,'% CI')
		}
		if(VIF)	{
			if(final.predictor==1){
				warn.vif <- '<li> Warning : VIF is not supported for intercept-only model.'
			} else {
				VIF.1 <- rms::vif(fit.final)
				if(!noint) {
				  VIF.1 <- c(NA,VIF.1)
				  names(VIF.1)[1] <- "(Intercept)"
				}
				
				tmp <- merge(CE,VIF.1,by='row.names',all=TRUE)
				rownames(tmp) <- tmp[,1]
				colnames(tmp)[ncol(tmp)] <- "VIF"
				CE <- tmp[,-1]
			}
		}
		if(VIP){
			if(final.predictor!=1){
				vip <- caret::varImp(fit.final)
				if(!noint) {
				  vip <- rbind(NA,vip)
				  rownames(vip)[1] <- "(Intercept)"
				}
				tmp <- merge(CE,vip,by='row.names',all=TRUE)
				rownames(tmp) <- tmp[,1]
				colnames(tmp)[ncol(tmp)] <- "VIP"
				CE <- tmp[,-1]
			} else {
				warn.VIP <- "<li> Warning : Variable importance table is not supported for intercept only model."
			}
		}
		R2HTML::HTML(Digits(CE),file="./test.html",align="left",digits=15)
		if(exists('warn.VIP')) R2HTML::HTML(warn.VIP,file="./test.html")
		if(exists('warn.VIF')) R2HTML::HTML(warn.VIF,file="./test.html")
	}
	if(type=='wlm') {
		fit.final <- lm(as.formula(form.final),data=dataset,weight=WTS)

		CE <- summary(fit.final)$coef
		if(CI){
			tmp <- merge(CE,confint(fit.final, level=confint.level),by="row.names",all=TRUE,sort=F)
			rownames(tmp) <- tmp[,1]
			CE <- tmp[,-1]
			colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of ',confint.level*100,'% CI')
		}
		if(VIF)	{
			if(final.predictor==1){
				warn.vif <- '<li> Warning : VIF is not supported for intercept-only model.'
			} else {
				VIF.1 <- rms::vif(fit.final)
				if(!noint) {
				VIF.1 <- c(NA,VIF.1)
				names(VIF.1)[1] <- "(Intercept)"
				}
				
				tmp <- merge(CE,VIF.1,by='row.names',all=TRUE)
				rownames(tmp) <- tmp[,1]
				colnames(tmp)[ncol(tmp)] <- "VIF"
				CE <- tmp[,-1]
			}
		}
		if(VIP){
			if(final.predictor!=1){
				vip <- caret::varImp(fit.final)
				if(!noint) {
				  vip <- rbind(NA,vip)
				  rownames(vip)[1] <- "(Intercept)"
				}

				tmp <- merge(CE,vip,by='row.names',all=TRUE)
				rownames(tmp) <- tmp[,1]
				colnames(tmp)[ncol(tmp)] <- "VIP"
				CE <- tmp[,-1]
			} else {
				warn.VIP <- "<li> Warning : Variable importance table is not supported for intercept only model."
			}
		}
		R2HTML::HTML(Digits(CE),file="./test.html",align="left",digits=15)
		if(exists('warn.VIP')) R2HTML::HTML(warn.VIP,file="./test.html")
		if(exists('warn.VIF')) R2HTML::HTML(warn.VIF,file="./test.html")
	}
	if(type=='binom') {
		command_str <- paste0("fit.final <- glm(",form.final,",data=dataset,family=binomial(",link,"))")
		eval(parse(text=command_str))

		CE <- as.data.frame(summary(fit.final)$coef)
		colnames(CE) <- c('Estimate','SE','Z-value','P-value')
		if(CI){
			tmp <- merge(CE,confint(fit.final, level=confint.level),by="row.names",all=TRUE,sort=F)
			rownames(tmp) <- tmp[,1]
			CE <- tmp[,-1]
			colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of<br>',confint.level*100,'% CI for <br>Estimate')
		}

		if(odds) {
			ORs <- exp(CE[,1,drop=F])
			colnames(ORs) <- 'exp(Estimate)'
			CE <- cbind(CE,ORs)
			CE <- CE[,c(1,ncol(CE),2:(ncol(CE)-1))]
			if(CI){
				tmp <- merge(CE,exp(confint(fit.final, level=confint.level)),by="row.names",all=TRUE,sort=F)
				rownames(tmp) <- tmp[,1]
				CE <- tmp[,-1]
				colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of<br>',confint.level*100,'% CI for<br>exp(Estimate)')
			}
		}

		if(VIF)	{
			if(final.predictor==1){
				warn.vif <- '<li> Warning : VIF is not supported for intercept-only model.'
			} else {
				VIF.1 <- rms::vif(fit.final)
				if(!noint) {
				VIF.1 <- c(NA,VIF.1)
				names(VIF.1)[1] <- "(Intercept)"
				}
					
				tmp <- merge(CE,VIF.1,by='row.names',all=TRUE)
				rownames(tmp) <- tmp[,1]
				colnames(tmp)[ncol(tmp)] <- "VIF"
				CE <- tmp[,-1]
			}
		}
		if(VIP){
			if(final.predictor!=1){
				vip <- varImp(fit.final)
				if(!noint) {
				vip <- rbind(NA,vip)
				rownames(vip)[1] <- "(Intercept)"
				}

				tmp <- merge(CE,vip,by='row.names',all=TRUE)
				rownames(tmp) <- tmp[,1]
				colnames(tmp)[ncol(tmp)] <- "VIP"
				CE <- tmp[,-1]
			} else {
				warn.msg9 <- "<li> Warning : Variable importance table is not supported for intercept only model."
			}
		}
		R2HTML::HTML(Digits(CE),file="./test.html",align="left",digits=15)
		if(exists('warn.msg9')) R2HTML::HTML(warn.msg9,file="./test.html")
		if(exists('warn.vif')) R2HTML::HTML(warn.vif,file="./test.html")
	}
	if(type=='multinom'){
		if (res_type == "nominal") {
			fit.final <- try(suppressWarnings(VGAM::vglm(as.formula(form.final), data=dataset, family=dist(refLevel = baseline, parallel=tmp.parallel))))
		} else {
			command_str	<- paste0("try(fit.final <- VGAM::vglm(",form.final,", data=dataset, family=dist(link=", link, ", parallel=tmp.parallel)))") ;
			suppressWarnings(eval(parse(text=command_str)))
		}

		CE <- data.frame(coef(summary(fit.final))) ;
		colnames(CE) <- c("Estimate","Std.Error","Z-value","P-value")
		if(CI){
			tmp <- merge(CE,confint(fit.final, level=confint.level),by="row.names",all=TRUE,sort=F)
			rownames(tmp) <- tmp[,1]
			CE <- tmp[,-1]
			colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of ',confint.level*100,'% CI')
		}
		if(exp_estim){
			CE <- cbind(CE,'exp(Estimate)'=exp(CE[,1]))
			CE <- CE[,c(1,ncol(CE),2:(ncol(CE)-1))]
		}

		if(res_type=='nominal'){
			tt <- sapply(printlevel, function(y) paste0("log(P(",dep_var,"=",y,")/P(",dep_var,"=",baseline,"))"))
		} else {
			tt <- sapply(seq(length(printlevel)), function(y) paste0(link, "(",printlevel[y],")"))
		}
		if(any(norm.parallel, ord.parallel)){
			for(ii in 1:length(printlevel)) {
				R2HTML::HTML(R2HTML::as.title(tt[ii]), HR=hr+2, file="./test.html")
				tmp.CE <- CE[c(ii,(1+length(printlevel)):nrow(CE)),]
				rownames(tmp.CE) <- gsub(paste0(":",ii,"$"),"",rownames(tmp.CE))
				R2HTML::HTML(Digits(tmp.CE), file="./test.html", na="", align="left", digits=15)	
			}
		} else {
			for(ii in 1:length(printlevel)) {
				R2HTML::HTML(R2HTML::as.title(tt[ii]), HR=hr+2, file="./test.html")
				tmp.CE <- CE[seq(from=ii,to=nrow(CE),by=length(printlevel)),]
				rownames(tmp.CE) <- gsub(paste0(":",ii,"$"),"",rownames(tmp.CE))
				R2HTML::HTML(Digits(tmp.CE), file="./test.html", na="", align="left", digits=15)	
			}
		}
	}
	if(type=='poisson'){
		command_str <- paste0("fit.final <- glm(",form.final,",data=dataset,family=dist(",link,"))")
		eval(parse(text=command_str))

		CE <- data.frame(coef(summary(fit.final))) ;
		colnames(CE) <- c("Estimate","Std.Error","Z-value","P-value")
		if(CI) {
			tmp <- merge(CE,confint(fit.final, level=confint.level),by="row.names",all=TRUE,sort=F)
			rownames(tmp) <- tmp[,1]
			CE <- tmp[,-1]
			colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of ',confint.level*100,'% CI')
		}
		if(exp_estim){
			CE <- cbind(CE,'exp(Estimate)'=exp(CE[,1]))
			CE <- CE[,c(1,ncol(CE),2:(ncol(CE)-1))]
		}
		if(VIF)	{
			if(is.null(vars)){
				warn.vif <- '<li> Warning : VIF is not supported for intercept-only model.'
			} else {
				VIF.1 <- rms::vif(fit.final)
				if(!noint) {
					VIF.1 <- c(NA,VIF.1)
					names(VIF.1)[1] <- "(Intercept)"
				}
                      
				tmp <- merge(CE,VIF.1,by='row.names',all=TRUE)
				rownames(tmp) <- tmp[,1]
				colnames(tmp)[ncol(tmp)] <- "VIF"
				CE <- tmp[,-1]
			}
		}
		R2HTML::HTML(Digits(CE),file="./test.html",align="left",digits=15)
	}
	if(type=='coxph') {
		final.predictor <- gsub("exp\\(|\\)","",final.predictor)
		form.final <- paste0("Surv(dataset[,time1], dataset[,event]) ~ ",gsub("-1","",final.predictor))
		fm <- formula(form.final)
		fit.final <- survival::coxph(fm, data=dataset)

		CE <- summary(fit.final)$coef
		colnames(CE) <- c('Estimate','exp(Estimate)','SE(Estimate)','Z-value','P-value')
		if(!expestim) CE <- CE[,-2,drop=F]
		if(CI){
			tmp <- merge(CE,confint(fit.final, level=confint.level),by="row.names",all=TRUE)
			rownames(tmp) <- tmp[,1]
			CE <- tmp[,-1]
			colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of<br>',confint.level*100,'% CI of<br> Estimate')
			if(expestim){
				CE <- cbind(CE,exp(CE[,(ncol(CE)-1):ncol(CE)]))
				colnames(CE)[(ncol(CE)-1):ncol(CE)] <- paste0(c('Lower','Upper'),' bound of<br>',confint.level*100,'% CI of<br> exp(Estimate)')
			}
		}
			
		R2HTML::HTML(Digits(CE), file="./test.html", align="left",digits=15)
	}
}

# Plot function for distribution
plotDistr <- function(x, p, discrete=FALSE, cdf=FALSE, regions = NULL, 
                          col = "gray", legend = TRUE, legend.pos = "topright",
                          main, xlab, ylab, ...){
  library(ggplot2)
  dat <- data.frame(x,p)
  
  theme_opt <- theme_bw() + 
    theme(panel.grid.minor=element_blank(), panel.grid.major=element_blank()) + 
    theme(plot.title = element_text(hjust = 0.5))
  
  ggp <- ggplot(aes(x=x, y=p), data=dat)
  if(discrete) ggp <- ggp + geom_point(size=2) + geom_segment(aes(xend=x, yend=0),lineend="butt")
  else ggp <- ggp + geom_line()
  if(cdf) ggp <- ggp + geom_hline(yintercept = 0:1, color="grey")
  else ggp <- ggp + geom_hline(yintercept = 0, color="grey")
  
  ggp <- ggp + theme_opt + labs(title=main, x=xlab, y=ylab)
  return(ggp)
}

# Plot function for distribution _ Modified in Rex ver 1.1
ggprob <- NULL
REx_ProbDist <- function(dist, param1, param2=NULL, param3=NULL, xmin, xmax, p=ggprob,
                           overlap=FALSE, color="#000000", fill=NULL, cdf, title=NULL){
  load.pkg(c("ggplot2", "ggfortify"))
  
  if(xmax-xmin<0) stop("최댓값은 최솟값보다 크거나 같아야 합니다.")
  cdf2 <- ifelse(cdf,"p","d")
  cdf3 <- ifelse(cdf,"CDF","PDF")
  eval(parse(text=paste0("dname <- ",cdf2,dist)))
  
  if(!overlap) p <- NULL
  
  switch(dist,
         norm={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           mean <- param1
           sd <- param2
           if(sd<0) stop("표준편차는 0 이상이어야 합니다.")
           ggp <- ggdistribution(dname, x, mean=mean, sd=sd, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Normal Distribution (",mu,"=",mean,", ",sigma^2,"=",sd^2,")"))
         },
         t={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           df <- param1
           ncp <- ifelse(is.null(param2),0,param2)
           if(df<=0) stop("자유도는 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, df=df, ncp=ncp, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of t Distribution (df=",df,", ncp=",ncp,")"))
         },
         chisq={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           df <- param1
           ncp <- ifelse(is.null(param2),0,param2)
           if(df<=0) stop("자유도는 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, df=df, ncp=ncp, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Chi-squared Distribution (df=",df,", ncp=",ncp,")"))
         },
         f={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           df1 <- param1
           df2 <- param2
           ncp <- ifelse(is.null(param3),0,param3)
           if(df1<=0|df2<=0) stop("자유도는 모두 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, df1=df1, df2=df2, ncp=ncp, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of F Distribution (df1=",df1,", df2=",df2,", ncp=",ncp,")"))
         },
         exp={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           rate <- param1
           if(rate<=0) stop("비율은 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, rate=rate, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Exponential Distribution (",lambda,"=",rate,")"))
         },
         unif={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           min <- param1
           max <- param2
           if(min>=max) stop("최댓값은 최솟값보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, min=min, max=max, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Uniform Distribution (min=",min,", max=",max,")"))
         },
         beta={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           shape1 <- param1
           shape2 <- param2
           if(shape1<=0|shape2<=0) stop("형상모수는 모두 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, shape1=shape1, shape2=shape2, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Beta Distribution (",alpha[1],"=",shape1,", ",alpha[2],"=",shape2,")"))
         },
         cauchy={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           location <- param1
           scale <- param2
           if(scale<=0) stop("척도모수는 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, location=location, scale=scale, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Cauchy Distribution (",mu,"=",location,", ",sigma,"=",scale,")"))
         }, 
         logis={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           location <- param1
           scale <- param2
           if(scale<=0) stop("척도모수는 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, location=location, scale=scale, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Logistic Distribution (",mu,"=",location,", ",sigma,"=",scale,")"))
         },
         lnorm={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           meanlog <- param1
           sdlog <- param2
           if(sdlog<0) stop("로그표준편차는 0 이상이어야 합니다.")
           ggp <- ggdistribution(dname, x, meanlog=meanlog, sdlog=sdlog, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Log-normal Distribution (",mu,"=",meanlog,", ",sigma^2,"=",sdlog^2,")"))
         },
         gamma={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           shape <- param1
           scale <- param2
           if(shape<0) stop("형상모수는 0 이상이어야 합니다.")
           if(scale<=0) stop("척도모수는 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, shape=shape, scale=scale, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Gamma Distribution (",alpha,"=",shape,", ",beta,"=",scale,")"))
         },
         weibull={
           x <- seq(xmin, xmax, (xmax-xmin)/10000)
           shape <- param1
           scale <- param2
           if(shape<=0|scale<=0) stop("형상모수와 척도모수는 0보다 커야 합니다.")
           ggp <- ggdistribution(dname, x, shape=shape, scale=scale, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Weibull Distribution (",alpha,"=",shape,", ",beta,"=",scale,")"))
         },
         binom={
           x <- ceiling(xmin):floor(xmax)
           if(cdf) x <- seq(xmin, xmax, (xmax-xmin)/10000)
           size <- param1
           prob <- param2
           if(size!=as.integer(size)|size<0) stop("시행횟수는 0 이상 정수만 가능합니다.")
           if(prob<0|prob>1) stop("성공확률은 0이상 1이하 입니다.")
           ggp <- ggdistribution(dname, x, size=size, prob=prob, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Binomial Distribution (n=",size,", p=",prob,")"))
         },
         pois={
           x <- ceiling(xmin):floor(xmax)
           if(cdf) x <- seq(xmin, xmax, (xmax-xmin)/10000)
           lambda2 <- param1
           if(lambda2<0) stop("평균은 0이상 입니다.")
           ggp <- ggdistribution(dname, x, lambda=lambda2, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Poisson Distribution (",lambda,"=",lambda2,")"))
         },
         geom={
           x <- ceiling(xmin):floor(xmax)
           if(cdf) x <- seq(xmin, xmax, (xmax-xmin)/10000)
           prob <- param1
           if(prob<=0|prob>1) stop("성공확률은 0초과 1이하 입니다.")
           ggp <- ggdistribution(dname, x, prob=prob, colour=color, fill=fill, p=p) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Geometric Distribution (p=",prob,")"))
         },
         hyper={
           x <- ceiling(xmin):floor(xmax)
           if(cdf) x <- seq(xmin, xmax, (xmax-xmin)/10000)
           m <- param1
           n <- param2
           k <- param3
           N <- m+n
           if(m!=as.integer(m)|m<0) stop("모집단 내 0과 1의 개수는 0 이상 정수만 가능합니다.")
           if(n!=as.integer(n)|n<0) stop("모집단 내 0과 1의 개수는 0 이상 정수만 가능합니다.")
           if(k!=as.integer(k)|k>(m+n)) stop("표본의 개수는 0 이상이고 모집단 크기 이하인 정수만 가능합니다.")
           ggp <- ggdistribution(dname, x, m=m, n=n, k=k, colour=color, fill=fill) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Hypergeometric Distribution (n=",k,"; N=",N,", K=",m,")"))
         },
         nbinom={
           x <- ceiling(xmin):floor(xmax)
           if(cdf) x <- seq(xmin, xmax, (xmax-xmin)/10000)
           size <- param1
           prob <- param2
           if(size<0) stop("성공목표횟수는 0보다 커야 합니다.")
           if(prob<=0|prob>1) stop("성공확률은 0초과 1이하 입니다.")
           ggp <- ggdistribution(dname, x, size=size, prob=prob, colour=color, fill=fill) 
           if(is.null(title)) title <- substitute(paste(cdf3," of Negative binomial Distribution (r=",size,", p=",prob,")"))
         })
  
  ggp <- ggp + geom_hline(yintercept = 0, color="grey") +
    scale_y_continuous(labels = scales::comma) +
    theme_bw() + theme(panel.grid.minor=element_blank(), panel.grid.major=element_blank()) + 
    theme(plot.title = element_text(hjust = 0.5)) + 
    labs(y="Density", title=title)
  
  assign("ggprob", ggp, envir=globalenv())
  return(ggp)
}


# Index plot

REx_indexplot <- function(varname, dataset, type="spike", id=TRUE, idnum=2, 
                          title=NULL, xlab="Observation Index", ylab=varname,
                          color="black", pch=19, lty=1, psize=1.5, pstroke=0.5, lsize=1, 
                          tick_x=NULL, tick_y=NULL, grid.major=T, grid.minor=T,
                          xlim=NULL, ylim=NULL, lim.expand=TRUE, 
                          title.size=NULL, axis.title.size=NULL, axis.text.size=NULL, id.size=NULL){
  load.pkg(c("ggplot2", "ggrepel"))
  
  suppressWarnings(datavar <- as.numeric(as.character(dataset[,varname])))
  if(sum(is.na(datavar))==length(datavar)) stop("There is no numeric values.")
  dataset <- data.frame(datavar)
  colnames(dataset) <- varname
  
  idn <- sort(order(datavar, decreasing = T)[1:idnum])
  datalab <- data.frame(x=idn, y=datavar[idn])
  
  themeopt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) themeopt <- themeopt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) themeopt <- themeopt + theme(panel.grid.minor = element_blank())
  
  if(!is.null(id.size)) id.size <- id.size * 0.3514598
  else id.size <- 10 * 0.3514598
  
  ggp <- ggplot(aes(x=1:nrow(dataset), eval(parse(text=paste0("y=",varname)))), data=dataset)
  if(type=="spike"){
    ggp <- ggp + geom_segment(aes(xend=1:nrow(dataset), yend=0), size=lsize, lineend="butt", color=color, linetype=lty, na.rm=T) + geom_hline(yintercept = 0)
    if(is.null(ylim)) ylim <- range(datavar, na.rm=T)
  }
  if(type=="dot") ggp <- ggp + geom_point(color=color, shape=pch, size=psize, stroke=pstroke, na.rm=T)
  
  if(id) ggp <- ggp + ggrepel::geom_text_repel(aes(x=x, y=y, label=x), data=datalab, hjust = 1.2, size=id.size)
  if(!is.null(tick_x)) ggp <- ggp + scale_x_continuous(breaks=as.numeric(names(tick_x)), labels = as.character(tick_x))
  if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = as.character(tick_y))
  
  ggp <- ggp + coord_cartesian(xlim=xlim, ylim=ylim, expand=lim.expand) + labs(list(title=title, x=xlab, y=ylab)) + themeopt
  return(ggp)
}

##### Dot plot

REx_dotplot <- function(varname, dataset, by=NULL, bin=NULL, type="stack", 
                        lgd.pos="right", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                        title=NULL, xlab=varname, color="black", color.group=NULL, label=T,
                        tick_x=NULL, grid.major=F, grid.minor=F,
                        xlim=NULL, lim.expand=TRUE, 
                        title.size=NULL, axis.title.size=NULL, axis.text.size=NULL, strip.text=NULL){
  load.pkg("ggplot2")
  suppressWarnings(datavar <- as.numeric(as.character(dataset[,varname])))
  if(sum(is.na(datavar))==length(datavar)) stop("There is no numeric values.")
  dataset2 <- data.frame(datavar)
  colnames(dataset2) <- "x"
  
  if(is.numeric(lgd.pos)){
    lgd.just <- lgd.pos/100
    if(!lgd.back) lgd.just <- 1.02*lgd.just-0.01
  }
  else lgd.just <- NULL
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  themeopt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.justification = lgd.just, legend.background = lgd.back2, 
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          strip.background = element_blank(), strip.placement = "outside", strip.text = element_text(size = strip.text),
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) themeopt <- themeopt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) themeopt <- themeopt + theme(panel.grid.minor = element_blank())
  
  if(is.null(by)){
    res <- ggplot(aes(x=x), data=dataset2)
    if(is.null(bin)) res <- res + geom_dotplot(method="histodot", color=color, fill=color, na.rm=T)
    else res <- res + geom_dotplot(method="histodot", binwidth=diff(range(datavar, na.rm=T))/bin, color=color, fill=color, na.rm=T)
    res <- res + scale_y_continuous(NULL, breaks = NULL) + labs(list(title=title, x=xlab)) + coord_cartesian(xlim=xlim, expand=lim.expand)
    if(!is.null(tick_x)) res <- res + scale_x_continuous(breaks=as.numeric(names(tick_x)), labels = as.character(tick_x))
    return(res + themeopt)
  } else {
    dataset2$group <- factor(dataset[,by])
    if(sum(is.na(dataset2$group))>0) dataset2 <- dataset2[-which(is.na(dataset2$group)),]
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
    if(!is.null(bin)) bin <- diff(range(datavar, na.rm=T))/bin
      
    if(type=="facet"){
      labelv <- NULL
      if(label){
        labelv <- paste0(by," = ",levels(dataset2$group))
        names(labelv) <- levels(dataset2$group)
      }
      if(is.null(xlim)) xlim <- range(datavar, na.rm=T)
      if(is.null(bin)) bin <- diff(range(datavar, na.rm=T))/30
    }
    
    ggp <- ggplot(aes(x=x, fill=group, color=group), data=dataset2) + 
      geom_dotplot(method="histodot", stackgroups = (type=="stack"), binwidth=bin, na.rm=T) + 
      scale_y_continuous(NULL, breaks = NULL)
    if(type=="facet") ggp <- ggp + facet_wrap(~group, ncol=1, scales="free", strip.position = "top", labeller = labeller(group=labelv))
    if(!is.null(tick_x)) ggp <- ggp + scale_x_continuous(breaks=as.numeric(names(tick_x)), labels = as.character(tick_x))
    ggp <- ggp + labs(list(title=title, x=xlab)) +
      guides(color = guide_legend(by), fill = guide_legend(by)) + 
      scale_fill_manual(values=color.group) + 
      scale_colour_manual(values=color.group) +
      coord_cartesian(xlim=xlim, expand=lim.expand) + 
      themeopt
    
    return(ggp)
  }
}

##### Histogram

REx_histogram <- function(varname, dataset, by=NULL, bin=30, scale="freq", type="stack", flip=FALSE, marg=FALSE, freq.poly=F, 
                          stat.test="none", stat.test.pos=NULL, stat.test.size=NULL, stat.test.gl=F,
                          lgd.pos="right", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                          title=NULL, xlab=varname, ylab=NULL, color="grey", color.group=NULL, label=T,
                          ext.hline=NULL, ext.vline=NULL,
                          tick_x=NULL, tick_y=NULL, grid.major=F, grid.minor=F,
                          marg.box=F, marg.ratio=0.2, color.marg="grey", margby=T, 
                          xlim=NULL, ylim=NULL, lim.expand=TRUE, 
                          title.size=NULL, axis.title.size=NULL, axis.text.size=NULL, strip.text=NULL){
  load.pkg(c("ggplot2", "cowplot", "grid", "gridExtra", "ggrepel", "reshape2"))
  suppressWarnings(datavar <- as.numeric(as.character(dataset[,varname])))
  if(sum(is.na(datavar))==length(datavar)) stop("There is no numeric values.")
  dataset2 <- data.frame(datavar)
  colnames(dataset2) <- "x"
  
  if(is.numeric(lgd.pos)){
    lgd.just <- lgd.pos/100
    if(!lgd.back) lgd.just <- 1.02*lgd.just-0.01
  }
  else lgd.just <- NULL
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.justification = lgd.just, legend.background = lgd.back2, 
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          strip.background = element_blank(), strip.placement = "outside", strip.text = element_text(size = strip.text),
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  if(is.null(ylab)){
    if(scale=="freq") ylab <- "Frequency"
    if(scale=="percent") ylab <- "Percent"
  }
  
  alpha <- ifelse(freq.poly, 0.3, NA)
  
  if(is.null(by)){
    ggp <- ggplot(aes(x), data=dataset2)
    if(scale=="freq"){
      ggp <- ggp + geom_histogram(bins=bin, color="black", fill=color, alpha=alpha, na.rm=T)
      if(freq.poly) ggp <- ggp + geom_freqpoly(bins=bin, color=color, size=1, na.rm=T)
      if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
      if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)))
    }
    if(scale=="percent"){
      ggp <- ggp + geom_histogram(aes(y = (..count..)/sum(..count..)), bins=bin, color="black", fill=color, alpha=alpha, na.rm=T)
      if(freq.poly) ggp <- ggp + geom_freqpoly(aes(y = (..count..)/sum(..count..)), bins=bin, color=color, size=1, na.rm=T)
      if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
      if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = scales::percent)
      else ggp <- ggp + scale_y_continuous(labels = scales::percent)
    }
  } else {
    dataset2$group <- factor(dataset[,by])
    if(sum(is.na(dataset2$group))>0) dataset2 <- dataset2[-which(is.na(dataset2$group)),]
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
    
    if(type=="par") hist_pos <- position_dodge()
    if(type=="identity"){
      hist_pos <- type
      alpha <- ifelse(freq.poly, 0.3, 0.5)
    }
    if(type=="stack") hist_pos <- position_stack()
    
    ggp <- ggplot(aes(x, fill=group), data=dataset2)
    
    if(type=="facet"){
      binwid <- diff(range(datavar, na.rm=T))/bin
      if(is.null(xlim)) xlim <- range(datavar, na.rm=T)
      labelv <- NULL
      if(label){
        labelv <- paste0(by," = ",levels(dataset2$group))
        names(labelv) <- levels(dataset2$group)
      }	
      if(scale=="freq"){
        ggp <- ggp + geom_histogram(binwidth=binwid, col="black", alpha=alpha, na.rm=T)
        if(freq.poly) ggp <- ggp + geom_freqpoly(aes(color=group), binwidth=binwid, size=1, na.rm=T, show.legend = F)
        if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
        if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)))
      }
      if(scale=="percent"){
        ggp <- ggp + geom_histogram(aes(y = (..count..)/sum(..count..)), binwidth=binwid, col="black", alpha=alpha, na.rm=T)
        if(freq.poly) ggp <- ggp + geom_freqpoly(aes(y = (..count..)/sum(..count..), color=group), binwidth=binwid, size=1, na.rm=T, show.legend = F)
        if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
        if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = scales::percent)
        else ggp <- ggp + scale_y_continuous(labels = scales::percent)
      }
      ggp <- ggp + facet_wrap(~group, ncol=1, scales="free_x", labeller = labeller(group=labelv))
    } else {
      if(scale=="freq"){
        ggp <- ggp + geom_histogram(bins=bin, color="black", position=hist_pos, alpha=alpha, na.rm=T)
        if(freq.poly) ggp <- ggp + geom_freqpoly(aes(color=group), bins=bin, position=hist_pos, size=1, na.rm=T, show.legend = F)
        if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
        if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)))
      }
      if(scale=="percent"){
        ggp <- ggp + geom_histogram(aes(y = (..count..)/sum(..count..)), bins=bin, color="black", position=hist_pos, alpha=alpha, na.rm=T)
        if(freq.poly) ggp <- ggp + geom_freqpoly(aes(y = (..count..)/sum(..count..), color=group), bins=bin, position=hist_pos, size=1, na.rm=T, show.legend = F)
        if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
        if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = scales::percent)
        else ggp <- ggp + scale_y_continuous(labels = scales::percent)
      }
      
      if(type=="identity" & stat.test!="none"){
        if(stat.test=="param"){
          if(length(levels(dataset2$group))==2){
            stat.test.name <- "Student's t-test"
            labp <- ifelse(t.test(x~group, dataset2)$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(t.test(x~group, dataset2)$p.value,4))))
            labtest <- paste0(stat.test.name,", p",labp)
          } else {
            stat.test.name <- "ANOVA"
            labp <- ifelse(summary(aov(x~group, dataset2))[[1]]$"Pr(>F)"[1]<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(summary(aov(x~group, dataset2))[[1]]$"Pr(>F)"[1],4))))
            labtest <- paste0(stat.test.name,", p",labp)
          }
          if(stat.test.gl){
            ext.vline.dat_stat <- dcast(dataset2, group~., mean, value.var = "x")
            ggp <- ggp + geom_vline(xintercept = ext.vline.dat_stat[,2], color=color.group, size=1)
          }
        } else {
          if (length(levels(dataset2$group))==2) {
			stat.test.name <- "Mann-Whitney U test"
            labp <- ifelse(wilcox.test(x~group, dataset2)$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(wilcox.test(x~group, dataset2)$p.value,4))))
            labtest <- paste0(stat.test.name,", p",labp)
          } else {
            stat.test.name <- "Kruskal-Wallis rank sum test"
            labp <- ifelse(kruskal.test(x~group, dataset2)$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(kruskal.test(x~group, dataset2)$p.value,4))))
            labtest <- paste0(stat.test.name,", p",labp)
          }
        }
        if(!is.null(stat.test.size)) stat.test.size <- stat.test.size * 0.3514598
        else stat.test.size <- 10 * 0.3514598
        
        if(is.null(stat.test.pos)){
          candx <- range(dataset2$x, na.rm=T)[1] + 0.2*diff(range(dataset2$x, na.rm=T))
          candy <- max(ggplot_build(ggp)$data[[1]]$y) * 1.1
          statdatpos <- data.frame(x=candx, y=candy)
        }
        else statdatpos <- data.frame(x=stat.test.pos[1], y=stat.test.pos[2])
        
        ggp <- ggp + ggrepel::geom_text_repel(aes(x=x, y=y), data=statdatpos, label = labtest, size=stat.test.size, inherit.aes = F, point.padding = NA, min.segment.length=10000)
      }
    }
    
    ggp <- ggp + guides(fill = guide_legend(by)) +
      scale_fill_manual(values=color.group) + 
      scale_color_manual(values=color.group)
  }
  
  if(!is.null(ext.hline)){
    ext.hline.dat <- list()
    for(j in 1:length(ext.hline)){
      ext.hline.dat[[j]] <- data.frame(yintercept=as.numeric(strsplit(ext.hline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.hline[[j]][2]), size=as.numeric(ext.hline[[j]][3]), color=ext.hline[[j]][4])
    }
    ext.hline.dat <- do.call(rbind, ext.hline.dat)
    ggp <- ggp + geom_hline(aes(yintercept = yintercept), ext.hline.dat, color=ext.hline.dat$color, linetype=ext.hline.dat$linetype, size=ext.hline.dat$size)
  } 
  if(!is.null(ext.vline)){
    ext.vline.dat <- list()
    for(j in 1:length(ext.vline)){
      ext.vline.dat[[j]] <- data.frame(xintercept=as.numeric(strsplit(ext.vline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.vline[[j]][2]), size=as.numeric(ext.vline[[j]][3]), color=ext.vline[[j]][4])
    }
    ext.vline.dat <- do.call(rbind, ext.vline.dat)
    ggp <- ggp + geom_vline(aes(xintercept = xintercept), ext.vline.dat, color=ext.vline.dat$color, linetype=ext.vline.dat$linetype, size=ext.vline.dat$size)
  } 
  
  if(!is.null(tick_x)) ggp <- ggp + scale_x_continuous(breaks=as.numeric(names(tick_x)), labels = as.character(tick_x))
  ggp <- ggp + labs(list(title=title, x=xlab, y=ylab))
  if(flip==TRUE) ggp <- ggp + coord_flip(xlim=xlim, ylim=ylim, expand=lim.expand)
  else ggp <- ggp + coord_cartesian(xlim=xlim, ylim=ylim, expand=lim.expand)
  ggp <- ggp + theme_opt
  
  if(!marg.box) return(ggp)
  else {
    xylim <- layer_scales(ggp)
    ggp_leg <- ggp_title <- NULL
    if(is.null(xlim)) xlim <- xylim$x$range$range
    if(lgd.pos %in% c("top", "bottom", "right", "left") & !is.null(by)){
      ggp_leg <- get_legend(ggp)
      ggp <- ggp + theme(legend.position = "none")
    }
    if(!is.null(title)){
      get_title <- function (plot) 
      {
        grobs <- plot_to_gtable(plot)$grobs
        legendIndex <- which(sapply(grobs, function(x) stringr::str_detect(x$name, "plot.title")))
        if (length(legendIndex) == 1) {
          legend <- grobs[[legendIndex]]
        }
        else {
          stop("Plot must contain a title")
        }
      }
      ggp_title <- get_title(ggp)
      ggp <- ggp + ggtitle(NULL)
    }
    marg.ratio <- c(1-marg.ratio, marg.ratio)
    
    if(!margby) by <- NULL
    ggp_up <- REx_boxplot(varname=varname, dataset=dataset, by=by, flip=T, marg=T,
                          ylim=xlim, lim.expand=lim.expand, lgd.pos = "none",
                          color=color.marg, color.group=color.group)
    ggp_tot <- plot_grid(ggp_up + 
                           theme(axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(),
                                 panel.border = element_blank(), panel.grid = element_blank()),
                         ggp, nrow=2, ncol=1, align = "v", rel_heights = rev(marg.ratio))
    
    if(is.null(ggp_leg)){
      if(is.null(ggp_title)) return(ggp_tot)
      else grid.arrange(ggp_tot, top=ggp_title)
    } else {
      if(is.null(ggp_title)) eval(parse(text=paste0("grid.arrange(ggp_tot, ",lgd.pos,"=ggp_leg)")))
      else{
        eval(parse(text=paste0("ggp_tot <- arrangeGrob(ggp_tot, ",lgd.pos,"=ggp_leg)")))
        grid.arrange(ggp_tot, top=ggp_title)
      }
    }
  }
}

##### Density

REx_densityplot <- function(varname, dataset, by=NULL, kernel="gaussian", binwid="nrd0", adj=1, densthres=NULL,
                            scale="density", type="stack", rug=T, flip=FALSE, marg=FALSE,
                            lgd.pos="right", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                            title=NULL, xlab=varname, ylab=NULL, color="black", color.group=NULL, alpha=0,
                            ext.hline=NULL, ext.vline=NULL,
                            tick_x=NULL, tick_y=NULL, grid.major=T, grid.minor=F,
                            xlim=NULL, ylim=NULL, lim.expand=TRUE, 
                            title.size=NULL, axis.title.size=NULL, axis.text.size=NULL){
  load.pkg("ggplot2")
  suppressWarnings(datavar <- as.numeric(as.character(dataset[,varname])))
  if(sum(is.na(datavar))==length(datavar)) stop("There is no numeric values.")
  dataset2 <- data.frame(datavar)
  colnames(dataset2) <- varname
  if(!is.null(by)){
    dataset2$group <- factor(dataset[,by])
    if(sum(is.na(dataset2$group))>0) dataset2 <- dataset2[-which(is.na(dataset2$group)),]
    colnames(dataset2)[2] <- by
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
  }
  
  if(is.numeric(lgd.pos)){
    lgd.just <- lgd.pos/100
    if(!lgd.back) lgd.just <- 1.02*lgd.just-0.01
  }
  else lgd.just <- NULL
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.justification = lgd.just, legend.background = lgd.back2, 
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  if(scale=="density"){
    count <- ""
    if(is.null(ylab)){
      if(type=="fill") ylab <- "Proportion"
      else ylab <- "Density"
    }
  }
  if(scale=="count"){
    count <- ", ..count.."
    if(is.null(ylab)) ylab <- "Count"
  }
  if(is.null(xlim)) xlim <- range(datavar, na.rm=T)
  
  if(is.null(by)){
    ggp <- ggplot(eval(parse(text=paste0("aes(x=",varname,count,")"))), data=dataset2) +
      stat_density(kernel=kernel, bw=binwid, adjust=adj, position=type, alpha=alpha, color=color, fill=color, na.rm=T)
    if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
  } else {
    ggp <- ggplot(eval(parse(text=paste0("aes(x=",varname,count,", fill=",by,", color=",by,")"))), data=dataset2) + 
      stat_density(kernel=kernel, bw=binwid, adjust=adj, position=type, alpha=alpha, na.rm=T)
    if(!marg) ggp <- ggp + geom_hline(yintercept = 0)
    ggp <- ggp + scale_fill_manual(values=color.group) + 
      scale_colour_manual(values=color.group)
  }
  
  ggp <- ggp + xlim(range(datavar, na.rm=T) + diff(range(datavar, na.rm=T))*c(-1,1)*adj)
  if(!is.null(densthres)){
    if(densthres > max(ggplot_build(ggp)$data[[1]][,"ymax"])) stop("밀도 하한을 더 낮게 설정해야 합니다.")
    xlim <- range(ggplot_build(ggp)$data[[1]][which(ggplot_build(ggp)$data[[1]][,"ymax"] > densthres),"x"])
  }
  
  if(rug) ggp <- ggp + geom_rug(aes(y=NULL), show.legend = F)
  
  if(!is.null(ext.hline)){
    ext.hline.dat <- list()
    for(j in 1:length(ext.hline)){
      ext.hline.dat[[j]] <- data.frame(yintercept=as.numeric(strsplit(ext.hline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.hline[[j]][2]), size=as.numeric(ext.hline[[j]][3]), color=ext.hline[[j]][4])
    }
    ext.hline.dat <- do.call(rbind, ext.hline.dat)
    ggp <- ggp + geom_hline(aes(yintercept = yintercept), ext.hline.dat, color=ext.hline.dat$color, linetype=ext.hline.dat$linetype, size=ext.hline.dat$size)
  } 
  if(!is.null(ext.vline)){
    ext.vline.dat <- list()
    for(j in 1:length(ext.vline)){
      ext.vline.dat[[j]] <- data.frame(xintercept=as.numeric(strsplit(ext.vline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.vline[[j]][2]), size=as.numeric(ext.vline[[j]][3]), color=ext.vline[[j]][4])
    }
    ext.vline.dat <- do.call(rbind, ext.vline.dat)
    ggp <- ggp + geom_vline(aes(xintercept = xintercept), ext.vline.dat, color=ext.vline.dat$color, linetype=ext.vline.dat$linetype, size=ext.vline.dat$size)
  } 
  
  if(!is.null(tick_x)) ggp <- ggp + scale_x_continuous(breaks=as.numeric(names(tick_x)), labels = as.character(tick_x), 
                                                       limits = range(datavar, na.rm=T) + diff(range(datavar, na.rm=T))*c(-1,1)*adj)
  if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)))
  ggp <- ggp + labs(list(title=title, x=xlab, y=ylab))
  if(flip==TRUE) ggp <- ggp + coord_flip(xlim=xlim, ylim=ylim, expand=lim.expand)
  else ggp <- ggp + coord_cartesian(xlim=xlim, ylim=ylim, expand=lim.expand)
  ggp <- ggp + theme_opt
  
  return(ggp)
}

####### Box

REx_boxplot <- function(varname, dataset, by=NULL, flip=FALSE, dot.data="none", 
                        stat.test="none", stat.test.pos=NULL, stat.test.size=NULL, 
                        lgd.pos="none", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                        box.mean=F, box.mean.pch=5, box.mean.psize=2.5, box.mean.pstroke=1.5, box.mean.color="red",
                        title=NULL, xlab=NULL, ylab=NULL, color="grey", color.group=NULL, ext.hline=NULL, 
                        tick_x=NULL, tick_y=NULL, grid.major=T, grid.minor=F,
                        ylim=NULL, lim.expand=TRUE, marg=F,
                        title.size=NULL, axis.title.size=NULL, axis.text.size=NULL){
  load.pkg(c("ggplot2", "ggrepel"))
  
  if(is.numeric(lgd.pos)){
    lgd.just <- lgd.pos/100
    if(!lgd.back) lgd.just <- 1.02*lgd.just-0.01
  }
  else lgd.just <- NULL
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.justification = lgd.just, legend.background = lgd.back2, 
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  if(length(varname)==1){
    suppressWarnings(datavar <- as.numeric(as.character(dataset[,varname])))
    if(sum(is.na(datavar))==length(datavar)) stop("There is no numeric values.")
    dataset2 <- data.frame(datavar)
    colnames(dataset2) <- "x"
    
    if(is.null(ylab)) ylab <- varname
    
    if(is.null(by)){
      boxbase <- ggplot(aes(x='0', y=x), data=dataset2) +
        stat_boxplot(geom="errorbar", width=0.4, na.rm=T, position=position_dodge(0.75)) + geom_boxplot(fill=color, na.rm=T) +
        labs(list(title=title, x=xlab, y=ylab))
      if(dot.data=="jitter") boxbase <- boxbase + geom_jitter(width=0.2, na.rm=T, show.legend = F)
      if(dot.data=="dot") boxbase <- boxbase + geom_dotplot(binaxis='y', stackdir='center', binwidth=diff(range(dataset2$x, na.rm=T))/50, fill=color, na.rm=T, show.legend = F)
    } else {
      dataset2$group <- factor(dataset[,by])
      if(sum(is.na(dataset2$group))>0) dataset2 <- dataset2[-which(is.na(dataset2$group)),]
      if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
      if(is.null(xlab)) xlab <- by
      
      if(marg) boxbase <- ggplot(aes(x="0", y=x, fill=group), data=dataset2)
      else boxbase <- ggplot(aes(x=group, y=x, fill=group), data=dataset2)
      boxbase <- boxbase + stat_boxplot(geom="errorbar", width=0.4, na.rm=T, position=position_dodge(0.75)) + geom_boxplot(na.rm=T) +
        guides(color = guide_legend(by), fill = guide_legend(by)) +
        labs(list(title=title, x=xlab, y=ylab))
      if(dot.data=="jitter") boxbase <- boxbase + geom_point(na.rm=T, position = position_jitterdodge(dodge.width = 0.75), show.legend = F)
      if(dot.data=="dot") boxbase <- boxbase + geom_dotplot(binaxis='y', stackdir='center', binwidth=diff(range(dataset2$x, na.rm=T))/50, na.rm=T, position = position_dodge(0.75), show.legend = F)
      if(!is.null(color.group)){
        boxbase <- boxbase + 
          scale_fill_manual(values=color.group) + 
          scale_colour_manual(values=color.group)
      }
      
      if(stat.test!="none"){
        if(stat.test=="param"){
          if(length(levels(dataset2$group))==2){
            stat.test.name <- "Student's t-test"
            labp <- ifelse(t.test(x~group, dataset2)$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(t.test(x~group, dataset2)$p.value,4))))
            labtest <- paste0(stat.test.name,", p",labp)
          } else {
            stat.test.name <- "ANOVA"
            labp <- ifelse(summary(aov(x~group, dataset2))[[1]]$"Pr(>F)"[1]<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(summary(aov(x~group, dataset2))[[1]]$"Pr(>F)"[1],4))))
            labtest <- paste0(stat.test.name,", p",labp)
          }
        } else {
          if(length(levels(dataset2$group))==2){
            stat.test.name <- "Mann-Whitney U test"
            labp <- ifelse(wilcox.test(x~group, dataset2)$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(wilcox.test(x~group, dataset2)$p.value,4))))
            labtest <- paste0(stat.test.name,", p",labp)
          } else {
            stat.test.name <- "Kruskal-Wallis rank sum test"
            labp <- ifelse(kruskal.test(x~group, dataset2)$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(kruskal.test(x~group, dataset2)$p.value,4))))
            labtest <- paste0(stat.test.name,", p",labp)
          }
        }
        if(!is.null(stat.test.size)) stat.test.size <- stat.test.size * 0.3514598
        else stat.test.size <- 10 * 0.3514598
        
        if(is.null(stat.test.pos)){
          candx <- 1.2
          candy <- max(dataset2$x, na.rm=T) * 1.1
          statdatpos <- data.frame(x=candx, y=candy)
        }
        else statdatpos <- data.frame(x=stat.test.pos[1], y=stat.test.pos[2])
        
        boxbase <- boxbase + ggrepel::geom_text_repel(aes(x=x, y=y), data=statdatpos, label = labtest, size=stat.test.size, inherit.aes = F, point.padding = NA, min.segment.length=10000)
      }
    }
  } else {
    dataset2 <- data.frame(values=as.numeric(as.matrix(dataset[,varname])),
                           name=factor(rep(varname, each=nrow(dataset)), levels=varname))
    suppressWarnings(dataset2$values <- as.numeric(as.character(dataset2$values)))
    if(sum(is.na(dataset2$values))==length(dataset2$values)) stop("There is no numeric values.")
    
    if(is.null(ylab)) ylab <- ""
    if(is.null(xlab)) xlab <- ""
    
    if(is.null(by)){
      boxbase <- ggplot(aes(x=name, y=values), data=dataset2) +
        stat_boxplot(geom="errorbar", width=0.4, na.rm=T, position=position_dodge(0.75)) + geom_boxplot(fill=color, na.rm=T) +
        labs(list(title=title, x=xlab, y=ylab))
      if(dot.data=="jitter") boxbase <- boxbase + geom_jitter(width=0.2, na.rm=T, show.legend = F)
      if(dot.data=="dot") boxbase <- boxbase + geom_dotplot(binaxis='y', stackdir='center', binwidth=diff(range(dataset2$values, na.rm=T))/50, fill=color, na.rm=T, show.legend = F)
    } else {
      dataset2$group <- factor(rep(dataset[,by], length(varname)))
      if(sum(is.na(dataset2$group))>0) dataset2 <- dataset2[-which(is.na(dataset2$group)),]
      if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
      boxbase <- ggplot(aes(x=name, y=values, fill=group), data=dataset2) +
        stat_boxplot(geom="errorbar", width=0.4, na.rm=T, position=position_dodge(0.75)) + geom_boxplot(na.rm=T) +
        guides(color = guide_legend(by), fill = guide_legend(by)) +
        labs(list(title=title, x=xlab, y=ylab))
      if(dot.data=="jitter") boxbase <- boxbase + geom_point(na.rm=T, position = position_jitterdodge(dodge.width = 0.75), show.legend = F)
      if(dot.data=="dot") boxbase <- boxbase + geom_dotplot(binaxis='y', stackdir='center', binwidth=diff(range(dataset2$values, na.rm=T))/50, na.rm=T, position=position_dodge(0.75), show.legend = F)
      if(!is.null(color.group)){
        boxbase <- boxbase + 
          scale_fill_manual(values=color.group) + 
          scale_colour_manual(values=color.group)
      }
    }
  }
  if(box.mean) boxbase <- boxbase + stat_summary(fun.y=mean, geom="point", shape=box.mean.pch, size=box.mean.psize, stroke=box.mean.pstroke, color=box.mean.color,
                                                 na.rm=T, position=position_dodge(0.75), show.legend = F)
  
  if(!is.null(ext.hline)){
    ext.hline.dat <- list()
    for(j in 1:length(ext.hline)){
      ext.hline.dat[[j]] <- data.frame(yintercept=as.numeric(strsplit(ext.hline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.hline[[j]][2]), size=as.numeric(ext.hline[[j]][3]), color=ext.hline[[j]][4])
    }
    ext.hline.dat <- do.call(rbind, ext.hline.dat)
    boxbase <- boxbase + geom_hline(aes(yintercept = yintercept), ext.hline.dat, color=ext.hline.dat$color, linetype=ext.hline.dat$linetype, size=ext.hline.dat$size)
  } 
  
  if(!is.null(tick_x)) boxbase <- boxbase + scale_x_discrete(breaks=as.character(names(tick_x)), labels = as.character(tick_x))
  if(!is.null(tick_y)) boxbase <- boxbase + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = as.character(tick_y))
  
  if(flip==TRUE){
    boxbase <- boxbase + coord_flip(ylim=ylim, expand=lim.expand) + theme_opt 
    if(length(varname)==1 & is.null(by)){
      boxbase <- boxbase + theme(axis.ticks.y = element_blank())
      if(!marg) boxbase <- boxbase + theme(axis.text.y = element_blank())
    }
    if(length(varname)>1) boxbase <- boxbase + theme(axis.text.y = element_text(size=rel(1.2)))
  } else {
    boxbase <- boxbase + coord_cartesian(ylim=ylim, expand=lim.expand) + theme_opt
    if(length(varname)==1 & is.null(by)){
      boxbase <- boxbase + theme(axis.ticks.x = element_blank())
      if(!marg) boxbase <- boxbase + theme(axis.text.x = element_blank())
    }
    if(length(varname)>1) boxbase <- boxbase + theme(axis.text.x = element_text(size=rel(1.2)))
  }
  return(boxbase)
}

#####Q-Q plot

REx_qqplot <- function(varname, dataset, dist="norm", distopt=NULL, line=TRUE, 
                       title=NULL, xlab=NULL, ylab=varname,
                       color.dot="black", color.line="red", pch=19, lty=1, psize=1.5, pstroke=0.5, lsize=0.5,
                       tick_x=NULL, tick_y=NULL, grid.major=T, grid.minor=F,
                       xlim=NULL, ylim=NULL, lim.expand=TRUE, 
                       title.size=NULL, axis.title.size=NULL, axis.text.size=NULL){
  
  load.pkg("ggplot2")
  
  suppressWarnings(datavar <- as.numeric(as.character(dataset[,varname])))
  if(sum(is.na(datavar))==length(datavar)) stop("There is no numeric values.")
  dataset2 <- data.frame(datavar)
  colnames(dataset2) <- "x"
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  get_estparam <- function(vec, method){
    load.pkg("fitdistrplus")
    i=1
    switch(method,
           norm={
             distopt <- fitdist(vec, "norm")$estimate
           },
           t={
             while(TRUE){
               j <- abs(rnorm(1, i*10, i))
               distopt <- fitdist(vec, "t", method="mge", gof="KS", start=list(df=j))$estimate
               if(is.na(distopt)){
                 i <- i+1
                 if(i>50) stop("모수 추정에 실패했습니다. 다른 분포를 선택하시거나, 직접 모수를 입력해주세요.")
               } 
               else break
             }
           },
           chisq={
             while(TRUE){
               j <- abs(rnorm(1, i*10, i))
               distopt <- fitdist(vec, "chisq", method="mge", gof="KS", start=list(df=j))$estimate
               if(is.na(distopt)){
                 i <- i+1
                 if(i>50) stop("모수 추정에 실패했습니다. 다른 분포를 선택하시거나, 직접 모수를 입력해주세요.")
               } 
               else break
             }
           },
           f={
             while(TRUE){
               j1 <- abs(rnorm(1, i*10, i))
               j2 <- abs(rnorm(1, i*10, i))
               distopt <- fitdist(vec, "f", method="mge", gof="KS", start=list(df1=j1, df2=j2))$estimate
               if(is.na(distopt)){
                 i <- i+1
                 if(i>50) stop("모수 추정에 실패했습니다. 다른 분포를 선택하시거나, 직접 모수를 입력해주세요.")
               } 
               else break
             }
           },
           unif={
             distopt <- range(vec, na.rm=T)
           }
    )
    return(distopt)
  }
  
  get_qqline <- function(vec, method, distopt, xlab){
    # browser()
    y <- quantile(vec[!is.na(vec)], c(0.25, 0.75))
    n <- length(vec)
    ord <- order(vec)
    ord.x <- vec[ord]
    P <- ppoints(length(vec))
    switch(method,
           norm={
             mean1 <- distopt[1]
             sd1 <- distopt[2]
             if(sd1<0) stop("표준편차는 0 이상이어야 합니다.")
             x <- qnorm(c(0.25, 0.75), mean1, sd1)
             z <- qnorm(P, mean1, sd1)
             dv <- dnorm(z, mean1, sd1)
             if(is.null(xlab)) xlab <- substitute(paste("Quantiles of Normal Distribution (",mu,"=",mean1,", ",sigma^2,"=",sd1^2,")"))
           },
           t={
             df1 <- distopt
             if(df1<0) stop("자유도는 0보다 커야 합니다.")
             x <- qt(c(0.25, 0.75),df1)
             z <- qt(P,df1)
             dv <- dt(z,df1)
             if(is.null(xlab)) xlab <- substitute(paste("Quantiles of t Distribution (df=",df1,")"))
           },
           chisq={
             df1 <- distopt
             if(df1<0) stop("자유도는 0보다 커야 합니다.")
             x <- qchisq(c(0.25, 0.75),df1)
             z <- qchisq(P,df1)
             dv <- dchisq(z,df1)
             if(is.null(xlab)) xlab <- substitute(paste("Quantiles of Chi-squared Distribution (df=",df1,")"))
           },
           f={
             df1 <- distopt[1]
             df2 <- distopt[2]
             if(df1<0|df2<0) stop("자유도는 모두 0보다 커야 합니다.")
             x <- qf(c(0.25, 0.75),df1,df2)
             z <- qf(P,df1,df2)
             dv <- df(z,df1,df2)
             if(is.null(xlab)) xlab <- substitute(paste("Quantiles of F Distribution (df1=",df1,", df2=",df2,")"))
           },
           unif={
             min1 <- distopt[1]
             max1 <- distopt[2]
             if(min1>max1) stop("최댓값은 최솟값보다 크거나 같아야 합니다.")
             x <- qunif(c(0.25,0.75), min1, max1)
             z <- qunif(P, min1, max1)
             dv <- dunif(z, min1, max1)
             if(is.null(xlab)) xlab <- substitute(paste("Quantiles of Uniform Distribution (min=",min1,", max=",max1,")"))
           }
    )
    slope <- diff(y)/diff(x)
    int <- y[1L] - slope * x[1L]
    zz <- qnorm(1 - (1 - 0.95)/2) # confidence level = 0.95
    SE <- (slope/dv) * sqrt(P * (1 - P)/n)
    fit.value <- int + slope * z
    upper <- fit.value + zz * SE
    lower <- fit.value - zz * SE
    df <- data.frame(x=z,y=ord.x,upper=upper,lower=lower)
    return(list(intercept=int,slope=slope,df=df,xlab=xlab))
  }
  
  if(is.null(distopt)) distopt <- get_estparam(na.exclude(datavar), dist)
  
  element_qqline <- get_qqline(na.exclude(datavar), dist, distopt, xlab)
  
  ggp <- ggplot(element_qqline$df,aes(x=x,y=y)) +
    geom_point(color=color.dot, shape=pch, size=psize, stroke=pstroke)
  if(line==TRUE){
    ggp <- ggp + geom_abline(color = color.line, slope = element_qqline$slope, intercept = element_qqline$intercept, linetype=lty, size=lsize) +
      geom_ribbon(aes(ymin = lower, ymax = upper), fill=color.dot, alpha=0.2)
  }
  if(!is.null(tick_x)) ggp <- ggp + scale_x_continuous(breaks=as.numeric(names(tick_x)))
  if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = as.character(tick_y))
  
  ggp <- ggp + coord_cartesian(xlim=xlim, ylim=ylim, expand=lim.expand) + 
    labs(list(title=title, x=element_qqline$xlab, y=ylab)) +
    theme_opt
  
  return(ggp)
}

#####Scatterplot

REx_scatterplot <- function(varname1, varname2, dataset, by=NULL, jitter.x=0, jitter.y=0, 
                            lineby=FALSE, LeastSq=FALSE, Ls.spread=FALSE, Ls.spread.type="confidence", Ls.level=0.95,
                            Ls.text="none", Ls.text.pos=NULL, Ls.text.size=NULL,
                            Smooth=FALSE, Sm.span=1, Sm.spread=FALSE, Ellipse=FALSE, Index=FALSE,
                            lgd.pos="bottom", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                            ext.dot=NULL, ext.abline=NULL, ext.hline=NULL, ext.vline=NULL,
                            title=NULL, xlab=varname1, ylab=varname2,
                            pch=19, psize=1.5, pstroke=0.5, color.dot="black", color.group=NULL, 
                            color.line.Ls="red", color.line.Sm="green", color.line.El="purple", color.line.Id="yellow",
                            marginal="none", marg.ratio=0.2, color.marg="grey", margby=T, 
                            marg.hist.bin=30, marg.dens.adj=1, 
                            tick_x=NULL, tick_y=NULL, grid.major=T, grid.minor=F,
                            xlim=NULL, ylim=NULL, lim.expand=TRUE, 
                            title.size=NULL, axis.title.size=NULL, axis.text.size=NULL){
  
  load.pkg(c("ggplot2","cowplot","grid","gridExtra", "ggrepel"))
  
  suppressWarnings(x <- as.numeric(as.character(dataset[,varname1])))
  suppressWarnings(y <- as.numeric(as.character(dataset[,varname2])))
  if(sum(is.na(x))==length(x)) stop("There is no numeric values.")
  if(sum(is.na(y))==length(y)) stop("There is no numeric values.")
  dat <- data.frame(x,y)
  
  jitter.x <- diff(range(x, na.rm=T))*jitter.x*0.01
  jitter.y <- diff(range(y, na.rm=T))*jitter.y*0.01
  
  if(!is.null(Ls.text.size)) Ls.text.size <- Ls.text.size * 0.3514598
  else Ls.text.size <- 10 * 0.3514598
  
  if(is.numeric(lgd.pos)){
    lgd.just <- lgd.pos/100
    if(!lgd.back) lgd.just <- 1.02*lgd.just-0.01
  }
  else lgd.just <- NULL
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.justification = lgd.just, legend.background = lgd.back2, 
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  if(is.null(by)){
    ggp <- ggplot(aes(x=x, y=y), data=dat) + geom_jitter(color=color.dot, width = jitter.x, height = jitter.y, shape=pch, size=psize, stroke=pstroke, na.rm=T)
    if(Index==TRUE) ggp <- ggp + geom_path(color=color.line.Id, show.legend=F, na.rm=T)
    if(Ellipse==TRUE) ggp <- ggp + stat_ellipse(color=color.line.El, show.legend=F, na.rm=T)
    if(Smooth==TRUE) ggp <- ggp + geom_smooth(method="loess", size=0.8, span=Sm.span, se=Sm.spread, color=color.line.Sm, fill=color.line.Sm, show.legend=F, na.rm=T)
    if(LeastSq==TRUE){
      if(!(Ls.spread.type=="prediction" & Ls.spread)) ggp <- ggp + stat_smooth(method = "lm", se=Ls.spread, color=color.line.Ls, fill=color.line.Ls, show.legend=F, na.rm=T, level = Ls.level)
      else {
        ggpLS <- ggp + stat_smooth(method = "lm", se=Ls.spread, color=color.line.Ls, fill=color.line.Ls, show.legend=F, na.rm=T, level = Ls.level)
        ggpLSdat <- ggplot_build(ggpLS)$data[[ifelse(Smooth,3,2)]]
        
        mod <- lm(y~x, dat)
        ggpLSpred <- predict(mod, data.frame(x=ggpLSdat$x), interval = "prediction", level = Ls.level)
        ggpLSdat$ymin <- ggpLSpred[,2]
        ggpLSdat$ymax <- ggpLSpred[,3]
        
        ggp <- ggp + geom_ribbon(aes(x=x, ymin=ymin, ymax=ymax), data=ggpLSdat, fill=color.line.Ls, alpha=0.2, show.legend=F, na.rm=T, inherit.aes = F) + 
          stat_smooth(method = "lm", se=F, color=color.line.Ls, show.legend=F, na.rm=T)
      }
    }
    if(LeastSq==TRUE & Ls.text!="none"){
      mod <- lm(y~x, dat)
      modcor <- cor.test(~x+y, dat)
      LSdat <- ggplot_build(ggp)$data[[ifelse(Smooth,3,2)]] 
      
      range_x <- range(dat$x, na.rm=T)
      range_x1 <- diff(range_x)*c(0.1,0.9) + range_x[1]
      range_x2 <- diff(range_x)*c(0.2,0.8) + range_x[1]
      range_y <- range(dat$y, na.rm=T)
      range_y1 <- diff(range_y)*c(0.2,0.8) + range_y[1]
      range_y2 <- diff(range(LSdat$y))*c(0.2,0.8) + range(LSdat$y)[1]
      
      if(mod$coefficients[2]>0){
        cand1 <- c(runif(1,range_x1[1],range_x2[1]), runif(1,min(c(range_y2[2], range_y1[2])), max(c(range_y2[2], range_y1[2]))))
        cand2 <- c(runif(1,range_x2[2],range_x1[2]), runif(1,min(c(range_y2[1], range_y1[1])), max(c(range_y2[1], range_y1[1]))))
      } else {
        cand1 <- c(runif(1,range_x1[1],range_x2[1]), runif(1,min(c(range_y2[2], range_y1[1])), max(c(range_y2[2], range_y1[1]))))
        cand2 <- c(runif(1,range_x2[2],range_x1[2]), runif(1,min(c(range_y2[1], range_y1[2])), max(c(range_y2[1], range_y1[2]))))
      }
      if(runif(1)>=0.5) cand3 <- cand1
      else cand3 <- cand2
      if(is.null(Ls.text.pos)) LSdatpos <- data.frame(x=cand3[1], y=cand3[2])
      else LSdatpos <- data.frame(x=Ls.text.pos[1], y=Ls.text.pos[2])
      
      if(Ls.text=="xy") labxy <- paste0("y=",sprintf("%.3f", mod$coefficients[1]),sprintf("%+.3f", mod$coefficients[2]),"x")
      if(Ls.text=="rp"){
        labp <- ifelse(modcor$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(modcor$p.value,4))))
        labxy <- paste0("r=",round(modcor$estimate,3),", p",labp)
      }
      if((Ls.spread | Sm.spread) & is.null(Ls.text.pos)) ggp <- ggp + ggrepel::geom_label_repel(aes(x=x, y=y), data=LSdatpos, label = labxy, size=Ls.text.size, inherit.aes = F, point.padding = NA)
      else ggp <- ggp + ggrepel::geom_text_repel(aes(x=x, y=y), data=LSdatpos, label = labxy, size=Ls.text.size, inherit.aes = F, point.padding = NA)
      
    }
  } else {
    group <- factor(dataset[,by])
    dat <- cbind(dat,group)
    if(sum(is.na(dat$group))>0) dat <- dat[-which(is.na(dat$group)),]
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
    
    if(length(pch)==1) pch <- rep(pch, length(levels(dat$group)))
    if(length(psize)==1) psize <- rep(psize, length(levels(dat$group)))
    if(length(pstroke)==1) pstroke <- rep(pstroke, length(levels(dat$group)))
    
    dat$stroke <- dat$group
    levels(dat$stroke) <- pstroke
    dat$stroke <- as.numeric(as.character(dat$stroke))
    
    ggp <- ggplot(aes(x=x, y=y, color=group, fill=group), data=dat) + 
      geom_jitter(aes(shape=group, size=group, stroke=stroke), width = jitter.x, height = jitter.y, na.rm=T) + 
      scale_shape_manual(values=pch) + scale_size_manual(values=psize)
    if(lineby==TRUE){
      if(Index==TRUE) ggp <- ggp + geom_path(aes(x=x, y=y, color=group, size=NULL, shape=NULL, stroke=NULL), show.legend=F, na.rm=T)
      if(Ellipse==TRUE) ggp <- ggp + stat_ellipse(aes(x=x, y=y, color=group, size=NULL, shape=NULL, stroke=NULL), show.legend=F, na.rm=T)
      if(Smooth==TRUE) ggp <- ggp + geom_smooth(aes(x=x, y=y, color=group, fill=group, size=NULL, shape=NULL, stroke=NULL), method="loess", size=0.8, span=Sm.span, se=Sm.spread, show.legend=F, na.rm=T)
      if(LeastSq==TRUE){
        if(!(Ls.spread.type=="prediction" & Ls.spread)) ggp <- ggp + stat_smooth(aes(x=x, y=y, color=group, fill=group, size=NULL, shape=NULL, stroke=NULL), method = "lm", se=Ls.spread, show.legend=F, na.rm=T, level = Ls.level)
        else {
          ggpLS <- ggp + stat_smooth(aes(x=x, y=y, color=group, fill=group, size=NULL, shape=NULL, stroke=NULL), method = "lm", se=Ls.spread, show.legend=F, na.rm=T, level = Ls.level)
          ggpLSdat <- ggplot_build(ggpLS)$data[[ifelse(Smooth,3,2)]]
          
          lev <- levels(group)
          for(llt in 1:length(lev)){
            ll <- lev[llt]
            datlev <- subset(dat, group==ll)
            mod <- lm(y~x, datlev)
            ggpLSpred <- predict(mod, data.frame(x=ggpLSdat$x[ggpLSdat$group==llt]), interval = "prediction", level = Ls.level)
            ggpLSdat$ymin[ggpLSdat$group==llt] <- ggpLSpred[,2]
            ggpLSdat$ymax[ggpLSdat$group==llt] <- ggpLSpred[,3]
          }
          
          ggp <- ggp + geom_ribbon(aes(x=x, ymin=ymin, ymax=ymax, group=group), data=ggpLSdat, fill=ggpLSdat$fill, alpha=0.2, show.legend=F, na.rm=T, inherit.aes = F) +
            stat_smooth(aes(x=x, y=y, color=group, fill=group, size=NULL, shape=NULL, stroke=NULL), method = "lm", se=F, show.legend=F, na.rm=T)
        }
      }
      if(LeastSq==TRUE & Ls.text!="none"){
        lev <- levels(group)
        LSdatpos <- data.frame(x=NA, y=NA, lab=NA)[-1,]
        Ls.text.pos_a <- diff(range(dat$y, na.rm=T))*0.02*Ls.text.size/3.514598
        Ls.text.pos_a <- Ls.text.pos_a*seq((length(lev)-1)/2, (1-length(lev))/2, length.out=length(lev))
        for(llt in 1:length(lev)){
          ll <- lev[llt]
          datlev <- subset(dat, group==ll)
          mod <- lm(y~x, datlev)
          modcor <- cor.test(~x+y, datlev)
          LSdat <- subset(ggplot_build(ggp)$data[[ifelse(Smooth,3,2)]], group==llt)
          
          range_x <- range(datlev$x, na.rm=T)
          range_x1 <- diff(range_x)*c(0.1,0.9) + range_x[1]
          range_x2 <- diff(range_x)*c(0.2,0.8) + range_x[1]
          range_y <- range(datlev$y, na.rm=T)
          range_y1 <- diff(range_y)*c(0.2,0.8) + range_y[1]
          range_y2 <- diff(range(LSdat$y))*c(0.2,0.8) + range(LSdat$y)[1]
          
          if(mod$coefficients[2]>0){
            cand1 <- c(runif(1,range_x1[1],range_x2[1]), runif(1,min(c(range_y2[2], range_y1[2])), max(c(range_y2[2], range_y1[2]))))
            cand2 <- c(runif(1,range_x2[2],range_x1[2]), runif(1,min(c(range_y2[1], range_y1[1])), max(c(range_y2[1], range_y1[1]))))
          } else {
            cand1 <- c(runif(1,range_x1[1],range_x2[1]), runif(1,min(c(range_y2[2], range_y1[1])), max(c(range_y2[2], range_y1[1]))))
            cand2 <- c(runif(1,range_x2[2],range_x1[2]), runif(1,min(c(range_y2[1], range_y1[2])), max(c(range_y2[1], range_y1[2]))))
          }
          if(runif(1)>=0.5) cand3 <- cand1
          else cand3 <- cand2
          
          if(Ls.text=="xy") labxy <- paste0("y=",sprintf("%.3f", mod$coefficients[1]),sprintf("%+.3f", mod$coefficients[2]),"x")
          if(Ls.text=="rp"){
            labp <- ifelse(modcor$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(modcor$p.value,4))))
            labxy <- paste0("r=",round(modcor$estimate,3),", p",labp)
          }
          
          if(is.null(Ls.text.pos)) LSdatpos <- rbind(LSdatpos, data.frame(x=cand3[1], y=cand3[2], lab=labxy))
          else LSdatpos <- rbind(LSdatpos, data.frame(x=Ls.text.pos[1], y=Ls.text.pos[2]+Ls.text.pos_a[llt], lab=labxy))
        }
        
        if((Ls.spread | Sm.spread) & is.null(Ls.text.pos)) ggp <- ggp + ggrepel::geom_label_repel(aes(x=x, y=y, label=lab), data=LSdatpos, color=color.group, size=Ls.text.size, inherit.aes = F, point.padding = NA)
        else ggp <- ggp + ggrepel::geom_text_repel(aes(x=x, y=y, label=lab), data=LSdatpos, color=color.group, size=Ls.text.size, inherit.aes = F, direction = "y", min.segment.length=10000, point.padding = NA)
      }
    } else {
      if(Index==TRUE) ggp <- ggp + geom_path(aes(x=x, y=y, color=NULL, size=NULL, shape=NULL, stroke=NULL), color=color.line.Id, show.legend=F, na.rm=T)
      if(Ellipse==TRUE) ggp <- ggp + stat_ellipse(aes(x=x, y=y, color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), color=color.line.El, show.legend=F, na.rm=T)
      if(Smooth==TRUE) ggp <- ggp + geom_smooth(aes(x=x, y=y, color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), method="loess", size=0.8, span=Sm.span, se=Sm.spread, color=color.line.Sm, fill=color.line.Sm, show.legend=F, na.rm=T)
      if(LeastSq==TRUE){
        if(!(Ls.spread.type=="prediction" & Ls.spread)) ggp <- ggp + stat_smooth(aes(x=x, y=y, color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), method = "lm", se=Ls.spread, color=color.line.Ls, fill=color.line.Ls, show.legend=F, na.rm=T, level = Ls.level)
        else {
          ggpLS <- ggp + stat_smooth(aes(x=x, y=y, color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), method = "lm", se=Ls.spread, color=color.line.Ls, fill=color.line.Ls, show.legend=F, na.rm=T, level = Ls.level)
          ggpLSdat <- ggplot_build(ggpLS)$data[[ifelse(Smooth,3,2)]]
          
          mod <- lm(y~x, dat)
          ggpLSpred <- predict(mod, data.frame(x=ggpLSdat$x), interval = "prediction", level = Ls.level)
          ggpLSdat$ymin <- ggpLSpred[,2]
          ggpLSdat$ymax <- ggpLSpred[,3]
          
          ggp <- ggp + geom_ribbon(aes(x=x, ymin=ymin, ymax=ymax), data=ggpLSdat, fill=color.line.Ls, alpha=0.2, show.legend=F, na.rm=T, inherit.aes = F) + 
            stat_smooth(aes(x=x, y=y, color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), method = "lm", se=F, color=color.line.Ls, show.legend=F, na.rm=T)
        }
      }
      if(LeastSq==TRUE & Ls.text!="none"){
        mod <- lm(y~x, dat)
        modcor <- cor.test(~x+y, dat)
        LSdat <- ggplot_build(ggp)$data[[ifelse(Smooth,3,2)]] 
        
        range_x <- range(dat$x, na.rm=T)
        range_x1 <- diff(range_x)*c(0.1,0.9) + range_x[1]
        range_x2 <- diff(range_x)*c(0.2,0.8) + range_x[1]
        range_y <- range(dat$y, na.rm=T)
        range_y1 <- diff(range_y)*c(0.2,0.8) + range_y[1]
        range_y2 <- diff(range(LSdat$y))*c(0.2,0.8) + range(LSdat$y)[1]
        
        if(mod$coefficients[2]>0){
          cand1 <- c(runif(1,range_x1[1],range_x2[1]), runif(1,min(c(range_y2[2], range_y1[2])), max(c(range_y2[2], range_y1[2]))))
          cand2 <- c(runif(1,range_x2[2],range_x1[2]), runif(1,min(c(range_y2[1], range_y1[1])), max(c(range_y2[1], range_y1[1]))))
        } else {
          cand1 <- c(runif(1,range_x1[1],range_x2[1]), runif(1,min(c(range_y2[2], range_y1[1])), max(c(range_y2[2], range_y1[1]))))
          cand2 <- c(runif(1,range_x2[2],range_x1[2]), runif(1,min(c(range_y2[1], range_y1[2])), max(c(range_y2[1], range_y1[2]))))
        }
        if(runif(1)>=0.5) cand3 <- cand1
        else cand3 <- cand2
        if(is.null(Ls.text.pos)) LSdatpos <- data.frame(x=cand3[1], y=cand3[2])
        else LSdatpos <- data.frame(x=Ls.text.pos[1], y=Ls.text.pos[2])
        
        if(Ls.text=="xy") labxy <- paste0("y=",sprintf("%.3f", mod$coefficients[1]),sprintf("%+.3f", mod$coefficients[2]),"x")
        if(Ls.text=="rp"){
          labp <- ifelse(modcor$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(modcor$p.value,4))))
          labxy <- paste0("r=",round(modcor$estimate,3),", p",labp)
        }
        
        if((Ls.spread | Sm.spread) & is.null(Ls.text.pos)) ggp <- ggp + ggrepel::geom_label_repel(aes(x=x, y=y), data=LSdatpos, label = labxy, size=Ls.text.size, inherit.aes = F, point.padding = NA)
        else ggp <- ggp + ggrepel::geom_text_repel(aes(x=x, y=y), data=LSdatpos, label = labxy, size=Ls.text.size, inherit.aes = F, point.padding = NA)
      }
    }
    if(!is.null(color.group)) ggp <- ggp + scale_colour_manual(values=color.group) + scale_fill_manual(values=color.group)
  }
  if(!is.null(ext.dot)){
    ext.dot.dat <- list()
    for(j in 1:length(ext.dot)){
      ext.dot2 <- ext.dot[[j]][1]
      ext.dot.dat[[j]] <- grep("[0-9.]+[ ]*,[ ]*[0-9.]+",unlist(strsplit(ext.dot2,"[()]")), value=T)
      ext.dot.dat[[j]] <- do.call(rbind, strsplit(ext.dot.dat[[j]],","))
      ext.dot.dat[[j]] <- data.frame(x=as.numeric(ext.dot.dat[[j]][,1]), y=as.numeric(ext.dot.dat[[j]][,2]), 
                                     shape=as.numeric(ext.dot[[j]][2]), size=as.numeric(ext.dot[[j]][3]), stroke=as.numeric(ext.dot[[j]][4]), color=ext.dot[[j]][5])
    }
    ext.dot.dat <- do.call(rbind, ext.dot.dat)
    ggp <- ggp + geom_point(mapping=aes(x=x,y=y), data=ext.dot.dat, color=ext.dot.dat$color, fill=ext.dot.dat$color, shape=ext.dot.dat$shape, size=ext.dot.dat$size, stroke=ext.dot.dat$stroke)
  } 
  if(!is.null(ext.abline)){
    ext.abline.dat <- list()
    for(j in 1:length(ext.abline)){
      ext.abline2 <- ext.abline[[j]][1]
      ext.abline.dat[[j]] <- grep("[0-9.]+[ ]*,[ ]*[0-9.]+",unlist(strsplit(ext.abline2,"[()]")), value=T)
      ext.abline.dat[[j]] <- do.call(rbind, strsplit(ext.abline.dat[[j]],","))
      ext.abline.dat[[j]] <- data.frame(intercept=as.numeric(ext.abline.dat[[j]][,1]), slope=as.numeric(ext.abline.dat[[j]][,2]),
                                        linetype=as.numeric(ext.abline[[j]][2]), size=as.numeric(ext.abline[[j]][3]), color=ext.abline[[j]][4])
    }
    ext.abline.dat <- do.call(rbind, ext.abline.dat)
    ggp <- ggp + geom_abline(aes(intercept=intercept, slope=slope), ext.abline.dat, color=ext.abline.dat$color, linetype=ext.abline.dat$linetype, size=ext.abline.dat$size)
  }
  if(!is.null(ext.hline)){
    ext.hline.dat <- list()
    for(j in 1:length(ext.hline)){
      ext.hline.dat[[j]] <- data.frame(yintercept=as.numeric(strsplit(ext.hline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.hline[[j]][2]), size=as.numeric(ext.hline[[j]][3]), color=ext.hline[[j]][4])
    }
    ext.hline.dat <- do.call(rbind, ext.hline.dat)
    ggp <- ggp + geom_hline(aes(yintercept = yintercept), ext.hline.dat, color=ext.hline.dat$color, linetype=ext.hline.dat$linetype, size=ext.hline.dat$size)
  } 
  if(!is.null(ext.vline)){
    ext.vline.dat <- list()
    for(j in 1:length(ext.vline)){
      ext.vline.dat[[j]] <- data.frame(xintercept=as.numeric(strsplit(ext.vline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.vline[[j]][2]), size=as.numeric(ext.vline[[j]][3]), color=ext.vline[[j]][4])
    }
    ext.vline.dat <- do.call(rbind, ext.vline.dat)
    ggp <- ggp + geom_vline(aes(xintercept = xintercept), ext.vline.dat, color=ext.vline.dat$color, linetype=ext.vline.dat$linetype, size=ext.vline.dat$size)
  } 
  
  if(!is.null(tick_x)) ggp <- ggp + scale_x_continuous(breaks=as.numeric(names(tick_x)), labels = as.character(tick_x))
  if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = as.character(tick_y))
  
  ggp <- ggp + theme_opt + 
    labs(list(title=title, x=xlab, y=ylab)) +
    coord_cartesian(xlim=xlim, ylim=ylim, expand=lim.expand)
  
  if(!is.null(by)) ggp <- ggp + guides(color = guide_legend(by, override.aes = list(shape=pch, size=psize, stroke=pstroke)),
                                       fill = guide_legend(by), shape=guide_legend(by), size=guide_legend(by))
  
  # if(is.null(ext.dot) & is.null(ext.abline) & is.null(ext.hline) & is.null(ext.vline)) {
  #   if(marginal=="histogram") ggp <- ggMarginal(ggp, type = "histogram", bins=marg.hist.bin, fill=color.marg, na.rm=T)
  #   if(marginal=="boxplot") ggp <- ggMarginal(ggp, type = "boxplot", fill=color.marg, size=10/marg.box.size, na.rm=T)
  #   if(marginal=="density") ggp <- ggMarginal(ggp, type = "density", color=color.marg, adjust=marg.dens.adj, na.rm=T)
  # }
  
  if(marginal=="none") return(ggp)
  else {
    xylim <- layer_scales(ggp)
    ggp_leg <- ggp_title <- NULL
    if(is.null(xlim)) xlim <- xylim$x$range$range
    if(is.null(ylim)) ylim <- xylim$y$range$range
    if(lgd.pos %in% c("top", "bottom", "right", "left") & !is.null(by)){
      ggp_leg <- get_legend(ggp)
      ggp <- ggp + theme(legend.position = "none")
    }
    if(!is.null(title)){
      get_title <- function (plot) 
      {
        grobs <- plot_to_gtable(plot)$grobs
        legendIndex <- which(sapply(grobs, function(x) stringr::str_detect(x$name, "plot.title")))
        if (length(legendIndex) == 1) {
          legend <- grobs[[legendIndex]]
        }
        else {
          stop("Plot must contain a title")
        }
      }
      ggp_title <- get_title(ggp)
      ggp <- ggp + ggtitle(NULL)
    }
    marg.ratio <- c(1-marg.ratio, marg.ratio)
    
    if(!margby) by <- NULL
    
    if(marginal=="histogram"){
      ggp_up <- REx_histogram(varname=varname1, dataset=dataset, by=by, marg=T,
                              bin=marg.hist.bin, xlim=xlim, lim.expand=lim.expand, lgd.pos = "none",
                              color=color.marg, color.group=color.group)
      ggp_rt <- REx_histogram(varname=varname2, dataset=dataset, by=by, flip=T, marg=T,
                              bin=marg.hist.bin, xlim=ylim, lim.expand=lim.expand, lgd.pos = "none",
                              color=color.marg, color.group=color.group, ylab=xlab)
    }
    if(marginal=="boxplot"){
      ggp_up <- REx_boxplot(varname=varname1, dataset=dataset, by=by, flip=T, marg=T,
                            ylim=xlim, lim.expand=lim.expand, lgd.pos = "none",
                            color=color.marg, color.group=color.group)
      ggp_rt <- REx_boxplot(varname=varname2, dataset=dataset, by=by, marg=T,
                            ylim=ylim, lim.expand=lim.expand, lgd.pos = "none",
                            color=color.marg, color.group=color.group, xlab=xlab)
    }
    if(marginal=="density"){
      ggp_up <- REx_densityplot(varname=varname1, dataset=dataset, by=by, marg=T, rug=F,
                                adj=marg.dens.adj, xlim=xlim, lim.expand=lim.expand, lgd.pos = "none",
                                color=color.marg, color.group=color.group, alpha=0.3)
      ggp_rt <- REx_densityplot(varname=varname2, dataset=dataset, by=by, flip=T, marg=T, rug=F,
                                adj=marg.dens.adj, xlim=ylim, lim.expand=lim.expand, lgd.pos = "none",
                                color=color.marg, color.group=color.group, alpha=0.3, ylab=xlab)
    }
    
    lt_part <- plot_grid(ggp_up + 
                           theme(axis.title = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(),
                                 panel.border = element_blank(), panel.grid = element_blank(),
                                 plot.margin = unit(c(8,0,0,8), "pt")),
                         ggp + theme(plot.margin = unit(c(1,1,8,8), "pt")),
                         nrow=2, ncol=1, align = "v", rel_heights = rev(marg.ratio))
    rt_part <- plot_grid(NULL, 
                         ggp_rt +
                           theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank(),
                                 axis.ticks.x = element_line(color="white"), axis.title.x = element_text(color="white", size=axis.title.size),
                                 axis.text.x = element_text(color="white", size=axis.text.size),
                                 panel.border = element_blank(), panel.grid = element_blank(),
                                 plot.margin = unit(c(1,8,8,0), "pt")),
                         nrow=2, ncol=1, align = "v", rel_heights = rev(marg.ratio))
    ggp2 <- plot_grid(lt_part, rt_part, nrow=1, ncol=2, align = "h", rel_widths = marg.ratio)
    
    if(is.null(ggp_leg)){
      if(is.null(ggp_title)) return(ggp2)
      else grid.arrange(ggp2, top=ggp_title)
    } else {
      if(is.null(ggp_title)) eval(parse(text=paste0("grid.arrange(ggp2, ",lgd.pos,"=ggp_leg)")))
      else{
        eval(parse(text=paste0("ggp2 <- arrangeGrob(ggp2, ",lgd.pos,"=ggp_leg)")))
        grid.arrange(ggp2, top=ggp_title)
      }
    }
  }
}

#####Scatter Matrix

REx_scattermatrix <- function(varname, dataset, by=NULL, jitter.x=0, jitter.y=0,
                              diagonal="none", lineby=FALSE, LeastSq=FALSE, Ls.spread=FALSE, Ls.level=0.95,
                              Smooth=FALSE, Sm.span=1, Sm.spread=FALSE, Ellipse=FALSE, Index=FALSE,
                              lgd.pos="right", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                              title=NULL, xlab=NULL, ylab=NULL, 
                              color.dot="black", color.group=NULL, 
							  color.line=NULL, ## tmparg for v.2.1.2
                              color.line.Ls="red", color.line.Sm="green", color.line.El="purple", color.line.Id="yellow",
                              pch=19, psize=1.5, pstroke=0.5, grid.major=F, grid.minor=F, 
                              diag.hist.bin=30, diag.dens.adj=1, color.diag="grey",
                              title.size=NULL, axis.title.size=NULL, axis.text.size=NULL, strip.text=NULL){
  
  load.pkg(c("GGally","ggplot2"))
  dat <- dataset[,varname]
  for(i in 1:ncol(dat)){
    suppressWarnings(dat[,i] <- as.numeric(as.character(dat[,i])))
    if(sum(is.na(dat[,i]))==nrow(dat)) stop("There is no numeric values.")
  }
  n <- length(varname)
  
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  ### tmpcode for v2.1.2
  if(!is.null(color.line)) color.line.Ls <- color.line.Sm <- color.line.El <- color.line.Id <- color.line
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.background = lgd.back2, strip.text = element_text(size = strip.text),
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  point_jitter <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    very <- as.character(mapping$y)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    very2 <- ifelse(length(very)==1, very, very[2])
    x <- data[,verx2]
    y <- data[,very2]
    jitter.x <- diff(range(x, na.rm=T))*jitter.x*0.01
    jitter.y <- diff(range(y, na.rm=T))*jitter.y*0.01
    ggplot(data = data, mapping=mapping) +
      geom_jitter(color=color.dot, shape=pch, size=psize, stroke=pstroke, width = jitter.x, height = jitter.y, na.rm=T) +
      guides(color = guide_legend(by), fill = guide_legend(by))
  }
  
  point_jitter_group <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    very <- as.character(mapping$y)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    very2 <- ifelse(length(very)==1, very, very[2])
    x <- data[,verx2]
    y <- data[,very2]
    jitter.x <- diff(range(x, na.rm=T))*jitter.x*0.01
    jitter.y <- diff(range(y, na.rm=T))*jitter.y*0.01
    ggplot(data = data, mapping=mapping) +
      geom_jitter(width = jitter.x, height = jitter.y, na.rm=T) +
      guides(color = guide_legend(by, override.aes = list(shape=pch, size=psize, stroke=pstroke)), 
             fill = guide_legend(by), shape=guide_legend(by), size=guide_legend(by))
  }
  
  qqDiag <- function(data, mapping, ...){
    get_qqline <- function(vec){
      y <- quantile(vec[!is.na(vec)], c(0.25, 0.75))
      n <- length(vec)
      ord <- order(vec)
      ord.x <- vec[ord]
      P <- ppoints(length(vec))
      x <- qnorm(c(0.25, 0.75))
      z <- qnorm(P)
      dv <- dnorm(z)
      slope <- diff(y)/diff(x)
      int <- y[1L] - slope * x[1L]
      zz <- qnorm(1 - (1 - 0.95)/2) # confidence level = 0.95
      SE <- (slope/dv) * sqrt(P * (1 - P)/n)
      fit.value <- int + slope * z
      upper <- fit.value + zz * SE
      lower <- fit.value - zz * SE
      df <- data.frame(x=z,y=ord.x,upper=upper,lower=lower)
      return(list(intercept=int,slope=slope,df=df))
    }
    verx <- as.character(mapping$x)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    element_qqline <- get_qqline(na.exclude(data[,verx2]))
    ggplot(element_qqline$df,aes(x=x,y=y)) +
      geom_point(color=color.diag) +
      geom_abline(slope = element_qqline$slope, intercept = element_qqline$intercept) +
      geom_ribbon(aes(ymin = lower, ymax = upper), alpha=0.2)
  }
  
  boxDiag <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    box <- ggplot(data = data, mapping=aes(x="",y=data[,verx2])) +
      stat_boxplot(geom="errorbar", color="black", width=0.4, na.rm=T, position=position_dodge(0.75)) + 
      geom_boxplot(fill=color.diag, color="black", size=0.5, shape=19, na.rm=T)
    return(box)
  }
  
  boxDiag_group <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    box <- ggplot(data = data, mapping=aes(x=group, y=data[,verx2], fill=group)) +
      stat_boxplot(geom="errorbar", width=0.4, na.rm=T, position=position_dodge(0.75)) + 
      geom_boxplot(size=0.5, shape=19, na.rm=T)
    if(!is.null(color.group)) box <- box + scale_fill_manual(values=color.group)
    return(box)
  }
  
  histoDiag <- function(data, mapping, ...){
    hist <- ggplot(data = data, mapping=mapping) +
      geom_histogram(color="black", fill=color.diag, bins=diag.hist.bin, size=0.5, na.rm=T)
    return(hist)
  }
  
  histoDiag_group <- function(data, mapping, ...){
    hist <- ggplot(data = data, mapping=mapping) +
      geom_histogram(color="black", bins=diag.hist.bin, size=0.5, na.rm=T)
    if(!is.null(color.group)) hist <- hist + scale_fill_manual(values=color.group)
    return(hist)
  }
  
  densDiag <- function(data, mapping, ...){
    dens <- ggplot(data = data, mapping=mapping) +
      geom_density(fill=color.diag, color=color.diag, alpha=0.3, adjust=diag.dens.adj, position="stack", size=0.5, na.rm=T)
    return(dens)
  }
  
  densDiag_group <- function(data, mapping, ...){
    dens <- ggplot(data = data, mapping=mapping) +
      geom_density(alpha=0.3, adjust=diag.dens.adj, position="stack", size=0.5, na.rm=T)
    if(!is.null(color.group)) dens <- dens + scale_fill_manual(values=color.group) + scale_colour_manual(values=color.group)
    return(dens)
  }
  
  if(is.null(by)){
    if(diagonal=="none") ggp <- ggpairs(data=dat, lower=list(continuous=point_jitter), upper=list(continuous=point_jitter), diag=NULL)
    if(diagonal=="density") ggp <- ggpairs(data=dat, lower=list(continuous=point_jitter), upper=list(continuous=point_jitter), diag = list(continuous = densDiag))
    if(diagonal=="histogram") ggp <- ggpairs(data=dat, lower=list(continuous=point_jitter), upper=list(continuous=point_jitter), diag = list(continuous = histoDiag))
    if(diagonal=="qqplot") ggp <- ggpairs(data=dat, lower=list(continuous=point_jitter), upper=list(continuous=point_jitter), diag=list(continuous = qqDiag))
    if(diagonal=="boxplot") ggp <- ggpairs(data=dat, lower=list(continuous=point_jitter), upper=list(continuous=point_jitter), diag=list(continuous = boxDiag))
    for(i in 1:ggp$nrow){
      for(j in 1:ggp$ncol){
        if(i == j) next else {
          if(Index==TRUE) ggp[i,j] <- ggp[i,j] + geom_path(color=color.line.Id, na.rm=T)
          if(Ellipse==TRUE) ggp[i,j] <- ggp[i,j] + stat_ellipse(color=color.line.El, na.rm=T)
          if(Smooth==TRUE) ggp[i,j] <- ggp[i,j] + geom_smooth(method="loess", size=0.8, span=Sm.span, se=Sm.spread, color=color.line.Sm, na.rm=T)
          if(LeastSq==TRUE) ggp[i,j] <- ggp[i,j] + geom_smooth(method = "lm", se=Ls.spread, level = Ls.level, color=color.line.Ls, na.rm=T)
        }
      }
    }
  } else {
    group <- factor(dataset[,by])
    dat <- cbind(dat,group)
    if(sum(is.na(dat$group))>0) dat <- dat[-which(is.na(dat$group)),]
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
    
    if(length(pch)==1) pch <- rep(pch, length(levels(dat$group)))
    if(length(psize)==1) psize <- rep(psize, length(levels(dat$group)))
    if(length(pstroke)==1) pstroke <- rep(pstroke, length(levels(dat$group)))
    
    dat$stroke <- dat$group
    levels(dat$stroke) <- pstroke
    dat$stroke <- as.numeric(as.character(dat$stroke))
    
    if(lgd.pos=="none") lgd.site <- NULL
    else lgd.site <- c(n,1)
    
    if(diagonal=="none") ggp <- ggpairs(data=dat, columns=1:n, ggplot2::aes(colour=group, shape=group, size=group, stroke=stroke), lower=list(continuous=point_jitter_group), upper=list(continuous=point_jitter_group), diag=NULL, legend=lgd.site)
    if(diagonal=="density") ggp <- ggpairs(data=dat, columns=1:n, ggplot2::aes(colour=group, fill=group, shape=group, size=group, stroke=stroke), lower=list(continuous=point_jitter_group), upper=list(continuous=point_jitter_group), diag = list(continuous = densDiag_group), legend=lgd.site)
    if(diagonal=="histogram") ggp <- ggpairs(data=dat, columns=1:n, ggplot2::aes(colour=group, fill=group, shape=group, size=group, stroke=stroke), lower=list(continuous=point_jitter_group), upper=list(continuous=point_jitter_group), diag = list(continuous = histoDiag_group), legend=lgd.site)
    if(diagonal=="qqplot") ggp <- ggpairs(data=dat, columns=1:n, ggplot2::aes(colour=group, shape=group, size=group, stroke=stroke), lower=list(continuous=point_jitter_group), upper=list(continuous=point_jitter_group), diag=list(continuous = qqDiag), legend=lgd.site)
    if(diagonal=="boxplot") ggp <- ggpairs(data=dat, columns=1:n, ggplot2::aes(colour=group, fill=group, shape=group, size=group, stroke=stroke), lower=list(continuous=point_jitter_group), upper=list(continuous=point_jitter_group), diag=list(continuous = boxDiag_group), legend=lgd.site)
    for(i in 1:ggp$nrow){
      for(j in 1:ggp$ncol){
        if(i == j) next else {
          if(lineby==TRUE){
            if(Index==TRUE) ggp[i,j] <- ggp[i,j] + geom_path(aes(size=NULL, shape=NULL, stroke=NULL), show.legend=FALSE, na.rm=T)
            if(Ellipse==TRUE) ggp[i,j] <- ggp[i,j] + stat_ellipse(aes(size=NULL, shape=NULL, stroke=NULL), show.legend=FALSE, na.rm=T)
            if(Smooth==TRUE) ggp[i,j] <- ggp[i,j] + geom_smooth(aes(size=NULL, shape=NULL, stroke=NULL), method="loess", span=Sm.span, se=Sm.spread, size=0.8, show.legend=FALSE, na.rm=T)
            if(LeastSq==TRUE) ggp[i,j] <- ggp[i,j] + geom_smooth(aes(size=NULL, shape=NULL, stroke=NULL), method = "lm", se=Ls.spread, level = Ls.level, show.legend=FALSE, na.rm=T)
          } else {
            if(Index==TRUE) ggp[i,j] <- ggp[i,j] + geom_path(aes(color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), color=color.line.Id, show.legend=FALSE, na.rm=T)
            if(Ellipse==TRUE) ggp[i,j] <- ggp[i,j] + stat_ellipse(aes(color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), color=color.line.El, show.legend=FALSE, na.rm=T)
            if(Smooth==TRUE) ggp[i,j] <- ggp[i,j] + geom_smooth(aes(color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), method="loess", color=color.line.Sm, span=Sm.span, se=Sm.spread, size=0.8, show.legend=FALSE, na.rm=T)
            if(LeastSq==TRUE) ggp[i,j] <- ggp[i,j] + geom_smooth(aes(color=NULL, fill=NULL, size=NULL, shape=NULL, stroke=NULL), method = "lm", color=color.line.Ls, se=Ls.spread, level = Ls.level, show.legend=FALSE, na.rm=T)
          }
          if(!is.null(color.group)) ggp[i,j] <- ggp[i,j] + scale_fill_manual(values=color.group) + scale_colour_manual(values=color.group)
          ggp[i,j] <- ggp[i,j] + scale_shape_manual(values=pch) + scale_size_manual(values=psize)
        }
      }
    }
  }
  ggp <- ggp + labs(x=xlab, y=ylab, title=title) + theme_opt
  return(ggp)
}

##### XY condition plot

REx_xyplot <- function(varname1, varname2, dataset, by=NULL, jitter.x=0, jitter.y=0,
                       on_one_panel=TRUE, scales="fixed", direction_by=NULL,
                       title=NULL, xlab=paste0(varname1, collapse = "+"), ylab=paste0(varname2, collapse = "+"),
                       pch=19, psize=1.5, pstroke=0.5, color.dot="black", color.group=NULL,
                       lgd.pos="top", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                       grid.major=F, grid.minor=F,
                       title.size=NULL, axis.title.size=NULL, axis.text.size=NULL, strip.text=NULL){
  
  load.pkg("ggplot2")
  
  # browser()
  dat <- dataset[,c(varname1, varname2)]
  for(i in 1:ncol(dat)){
    suppressWarnings(dat[,i] <- as.numeric(as.character(dat[,i])))
    if(sum(is.na(dat[,i]))==nrow(dat)) stop("There is no numeric values.")
  }
  # n <- length(varname)
  xname <- paste0(varname1, collapse = ".")
  yname <- paste0(varname2, collapse = ".")
  if(xname==yname) xname <- paste0(xname, "_")
  
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.background = lgd.back2, strip.text = element_text(size = strip.text),
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  nd2 <- 0
  dat2 <- list()
  for(j1 in 1:(length(varname1))){
    for(j2 in 1:(length(varname2))){
      nd2 <- nd2+1
      dat2[[nd2]] <- cbind(dat[,c(varname1[j1], varname2[j2])], varname1[j1], varname2[j2])
      colnames(dat2[[nd2]]) <- c("x", "y", xname, yname)
    }
  }
  dat2 <- do.call(rbind,dat2)
  
  jitter.x <- diff(range(dat2$x, na.rm=T))*jitter.x*0.01
  jitter.y <- diff(range(dat2$y, na.rm=T))*jitter.y*0.01
  
  if(is.null(by)){
    ggp <- ggplot(aes(x=x, y=y), data=dat2) + geom_jitter(color=color.dot, shape=pch, size=psize, stroke=pstroke, width = jitter.x, height = jitter.y, na.rm=T)
    ggp <- ggp + facet_grid(as.formula(paste0(yname, " ~ ",xname)), scales=scales)
    
  } else {
    dat3 <- dataset[by]
    for(i2 in 1:ncol(dat3)) dat3[,i2] <- factor(dat3[,i2])
    dat2 <- cbind(dat2, dat3)
    for(i3 in by) if(sum(is.na(dat2[,i3]))>0) dat2 <- dat2[-which(is.na(dat2[,i3])),]
    dat2$group <- interaction(dat2[,by])
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dat2$group))))
    
    if(length(pch)==1) pch <- rep(pch, length(levels(dat2$group)))
    if(length(psize)==1) psize <- rep(psize, length(levels(dat2$group)))
    if(length(pstroke)==1) pstroke <- rep(pstroke, length(levels(dat2$group)))
    
    dat2$stroke <- dat2$group
    levels(dat2$stroke) <- pstroke
    dat2$stroke <- as.numeric(as.character(dat2$stroke))
    
    ggp <- ggplot(aes(x=x, y=y, color=group, shape=group, size=group, stroke=stroke), data=dat2) + geom_jitter(width = jitter.x, height = jitter.y, na.rm=T) +
      guides(color = guide_legend(paste0(by, collapse="."), override.aes = list(shape=pch, size=psize, stroke=pstroke)), 
             fill = guide_legend(paste0(by, collapse=".")), shape=guide_legend(paste0(by, collapse=".")), size=guide_legend(paste0(by, collapse=".")))
    
    if(on_one_panel==T) ggp <- ggp + facet_grid(as.formula(paste0(yname, " ~ ",xname)), scales=scales)
    else {
      if(length(by[direction_by=="v"])!=0) {
        xname <- paste0(xname, " + ", paste0(by[direction_by=="v"], collapse=" + "))
        xsp <- rep(c(rep(0,length(levels(interaction(dat2[,by[direction_by=="v"]])))-1),0.5), length(varname1))
        xsp <- xsp[-length(xsp)]
      } else {
        xsp <- 0
      }
      if(length(by[direction_by=="h"])!=0) {
        yname <- paste0(yname, " + ", paste0(by[direction_by=="h"], collapse=" + "))
        ysp <- rep(c(rep(0,length(levels(interaction(dat2[,by[direction_by=="h"]])))-1),0.5), length(varname2))
        ysp <- ysp[-length(ysp)]
      } else {
        ysp <- 0
      }
      # browser()
      
      ggp <- ggp + facet_grid(as.formula(paste0(yname, " ~ ",xname)), scales=scales) + 
        theme(panel.spacing.x=unit(xsp, "lines"), panel.spacing.y=unit(ysp, "lines"))
    }
    if(!is.null(color.group)) ggp <- ggp + scale_colour_manual(values=color.group)
    ggp <- ggp + scale_shape_manual(values=pch) + scale_size_manual(values=psize)
  }
  ggp <- ggp + labs(x=xlab, y=ylab, title=title) + theme_opt
  return(ggp)
}

#####Mean plot

REx_meanplot <- function(varname, dataset, by1, by2=NULL, type="dot",
                         errbar="se", conflevel=0.95, line=TRUE, uperr=FALSE,
                         title=NULL, xlab=by1, ylab=varname, ext.hline=NULL, 
                         lgd.pos="right", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                         pch=19, lty=1, psize=1.5, pstroke=0.5, lsize=0.5,
                         color.dot="black", color.line="red", color.bar="grey", color.group=NULL,
                         tick_y=NULL, grid.major=F, grid.minor=F, ylim=NULL, lim.expand=TRUE, 
                         title.size=NULL, axis.title.size=NULL, axis.text.size=NULL){
  
  load.pkg("ggplot2")
  
  if(is.numeric(lgd.pos)){
    lgd.just <- lgd.pos/100
    if(!lgd.back) lgd.just <- 1.02*lgd.just-0.01
  }
  else lgd.just <- NULL
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.justification = lgd.just, legend.background = lgd.back2, 
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  pd <- position_dodge(0.3)
  
  suppressWarnings(datavar <- as.numeric(as.character(dataset[,varname])))
  if(sum(is.na(datavar))==length(datavar)) stop("There is no numeric values.")
  
  databy1 <- factor(dataset[,by1])
  gp1 <- levels(databy1)
  
  if(is.null(by2)){
    gpmean <- upper <- lower <- c()
    for(i in 1:length(gp1)){
      datapiece <- datavar[databy1==gp1[i]]
      gpmean[i] <- mean(datapiece, na.rm=TRUE)
      gpsd <- sd(datapiece, na.rm=TRUE)
      gpse <- gpsd/sqrt(length(datapiece))
      switch(errbar, 
             se={
               upper[i] <- gpmean[i] + gpse
               lower[i] <- gpmean[i] - gpse
             },
             sd={
               upper[i] <- gpmean[i] + gpsd
               lower[i] <- gpmean[i] - gpsd
             },
             conf={
               int <- qnorm((1-conflevel)/2, lower.tail = F)
               upper[i] <- gpmean[i] + gpse*int
               lower[i] <- gpmean[i] - gpse*int
             },
             none={
               upper[i] <- gpmean[i]
               lower[i] <- gpmean[i]
             }
      )
    } 
    meandat <- data.frame(x = gp1, y = gpmean, upper, lower)
    if(type=="dot"){
      ggp <- ggplot(aes(x=x, y=y), data=meandat) + geom_point(color=color.dot, shape=pch, size=psize, stroke=pstroke, na.rm=TRUE)
      if(line==TRUE) ggp <- ggp + geom_line(aes(group=1), color=color.line, linetype=lty, size=lsize, na.rm=TRUE) 
    }
    if(type=="bar"){
      ggp <- ggplot(aes(x=x, y=y), data=meandat) + geom_col(fill=color.bar, color="black", na.rm=TRUE) + geom_hline(yintercept = 0)
    }
  } else {
    databy2 <- factor(dataset[,by2])
    gp2 <- levels(databy2)
    gp2rep <- rep(gp2, each=length(gp1))
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by2]))))
    
    if(length(pch)==1) pch <- rep(pch, length(gp2))
    if(length(psize)==1) psize <- rep(psize, length(gp2))
    if(length(pstroke)==1) pstroke <- rep(pstroke, length(gp2))
    if(length(lty)==1) lty <- rep(lty, length(gp2))
    
    gp2stroke <- rep(pstroke, each=length(gp1))
    gpmean <- upper <- lower <- c()
    for(i in 1:length(gp2)){
      for(j in 1:length(gp1)){
        ij <- (i-1)*length(gp1)+j
        datapiece <- datavar[databy1==gp1[j] & databy2==gp2[i]]
        gpmean[ij] <- mean(datapiece, na.rm=TRUE)
        gpsd <- sd(datapiece, na.rm=TRUE)
        gpse <- gpsd/sqrt(length(datapiece))
        switch(errbar, 
               se={
                 upper[ij] <- gpmean[ij] + gpse
                 lower[ij] <- gpmean[ij] - gpse
               },
               sd={
                 upper[ij] <- gpmean[ij] + gpsd
                 lower[ij] <- gpmean[ij] - gpsd
               },
               conf={
                 int <- qnorm((1-conflevel)/2, lower.tail = F)
                 upper[ij] <- gpmean[ij] + gpse*int
                 lower[ij] <- gpmean[ij] - gpse*int
               },
               none={
                 upper[i] <- gpmean[i]
                 lower[i] <- gpmean[i]
               }
        )
      }
    }
    
    meandat <- data.frame(x = gp1, y = gpmean, group = gp2rep, stroke=gp2stroke, upper, lower)
    if(type=="dot"){
      ggp <- ggplot(aes(x=x, y=y, color=group, shape=group, size=group, stroke=stroke),data=meandat) + geom_point(position=pd, na.rm=TRUE) + 
        guides(color = guide_legend(by2, override.aes = list(shape=pch, size=psize, stroke=pstroke)), 
               fill = guide_legend(by2), shape=guide_legend(by2), size=guide_legend(by2))
      if(line==TRUE) ggp <- ggp + geom_line(aes(group=group, linetype=group),position=pd, size=lsize, na.rm=TRUE, show.legend = F)
      if(!is.null(color.group)) ggp <- ggp + scale_colour_manual(values=color.group)
      ggp <- ggp + scale_shape_manual(values=pch) + scale_size_manual(values=psize) + scale_linetype_manual(values=lty)
    }
    if(type=="bar"){
      ggp <- ggplot(aes(x=x, y=y, fill=group), data=meandat) + geom_col(color="black", position=position_dodge(), na.rm=TRUE) + geom_hline(yintercept = 0) + 
        guides(fill = guide_legend(by2))
      if(!is.null(color.group)) ggp <- ggp + scale_fill_manual(values=color.group)
    }
  }
  if(errbar!="none"){
    if(type=="dot") ggp <- ggp + geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.4, size=0.5, position=pd, na.rm=TRUE, show.legend = F)
    if(type=="bar"){
      if(uperr) ggp <- ggp + geom_errorbar(aes(ymin = y, ymax = upper), width = 0.4, size=0.5, na.rm=TRUE, position=position_dodge(width=0.9), show.legend = F)
      else ggp <- ggp + geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.4, size=0.5, na.rm=TRUE, position=position_dodge(width=0.9), show.legend = F)
    }
  }
  
  if(!is.null(ext.hline)){
    ext.hline.dat <- list()
    for(j in 1:length(ext.hline)){
      ext.hline.dat[[j]] <- data.frame(yintercept=as.numeric(strsplit(ext.hline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.hline[[j]][2]), size=as.numeric(ext.hline[[j]][3]), color=ext.hline[[j]][4])
    }
    ext.hline.dat <- do.call(rbind, ext.hline.dat)
    ggp <- ggp + geom_hline(aes(yintercept = yintercept), ext.hline.dat, color=ext.hline.dat$color, linetype=ext.hline.dat$linetype, size=ext.hline.dat$size)
  } 
  
  if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = as.character(tick_y))
  ggp <- ggp + 
    coord_cartesian(ylim=ylim, expand=lim.expand) + 
    labs(list(title=title, x=xlab, y=ylab)) + 
    theme_opt
  return(ggp)
}

#####Bar plot

REx_barplot <- function(varname, dataset, by=NULL, flip=FALSE, type="stack", 
                        stat.test=F, stat.test.pos=NULL, stat.test.size=NULL, 
                        title=NULL, xlab=varname, ylab="Frequency", label=T, ext.hline=NULL, 
                        lgd.pos="right", lgd.back=F, lgd.title=NULL, lgd.text=NULL, 
                        color="grey", color.group=NULL, freq.info=F, freq.size=NULL, freq.pos.top=T,
                        tick_y=NULL, grid.major=F, grid.minor=F, ylim=NULL, lim.expand=TRUE, 
                        title.size=NULL, axis.title.size=NULL, axis.text.size=NULL, strip.text=NULL){
  load.pkg(c("ggplot2", "ggrepel"))
  
  if(is.numeric(lgd.pos)){
    lgd.just <- lgd.pos/100
    if(!lgd.back) lgd.just <- 1.02*lgd.just-0.01
  }
  else lgd.just <- NULL
  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme_bw() + 
    theme(plot.title = element_text(hjust = 0.5, size = title.size),
          legend.position = lgd.pos, legend.justification = lgd.just, legend.background = lgd.back2, 
          legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text), 
          strip.background = element_blank(), strip.placement = "outside", strip.text = element_text(size = strip.text), 
          axis.text = element_text(size = axis.text.size), axis.title = element_text(size = axis.title.size))
  if(!(grid.major)) theme_opt <- theme_opt + theme(panel.grid.major = element_blank())
  if(!(grid.minor)) theme_opt <- theme_opt + theme(panel.grid.minor = element_blank())
  
  if(!is.null(freq.size)) freq.size <- freq.size * 0.3514598
  else freq.size <- 10 * 0.3514598
  
  x <- factor(dataset[,varname])
  if(flip==TRUE) x <- factor(x, levels=rev(levels(x)))
  dat <- data.frame(x)
  if(!is.null(by)) dat$group <- factor(dataset[,by])
  dat <- na.exclude(dat)
  
  if(is.null(by)){
    dat1 <- data.frame(x=factor(names(table(dat$x)), levels=levels(x)), y=as.integer(table(dat$x)))
    
    ggp <- ggplot(aes(x, y), data=dat1) + geom_col(fill=color, color="black", na.rm=T) + geom_hline(yintercept = 0)
    if(freq.info){
      if(flip) ggp <- ggp + ggrepel::geom_text_repel(aes(label = y), size=freq.size, hjust=as.integer(freq.pos.top))
      else ggp <- ggp + ggrepel::geom_text_repel(aes(label = y), size=freq.size, vjust=as.integer(freq.pos.top))
    }
  } else {
    dat2 <- data.frame(x=factor(rep(rownames(table(dat)),ncol(table(dat))), levels=levels(x)), 
                       y=as.integer(table(dat)), group=factor(rep(levels(dat$group), each=nrow(table(dat)))))
    dat3 <- dat2[which(dat2$y!=0),]
    
    if(is.null(color.group)) color.group <- gg_color_hue2(length(levels(factor(dataset[,by]))))
    if(type=="stack"){
      ggp <- ggplot(aes(x, y, fill=group), data=dat3) + geom_col(color="black", na.rm=T) + geom_hline(yintercept = 0)
      if(freq.info){
        if(flip) ggp <- ggp + ggrepel::geom_text_repel(aes(label = y), size=freq.size, position="stack", hjust=as.integer(freq.pos.top))
        else ggp <- ggp + ggrepel::geom_text_repel(aes(label = y), size=freq.size, position="stack", vjust=as.integer(freq.pos.top))
      }
    }
    if(type=="par"){
      dat2$just <- as.integer(freq.pos.top)
      dat2$just[dat2$y==0] <- 1
      ggp <- ggplot(aes(x, y, fill=group), data=dat2) + geom_col(color="black", na.rm=T, position=position_dodge(width = 0.9)) + geom_hline(yintercept = 0)
      if(freq.info){
        if(flip) ggp <- ggp + ggrepel::geom_text_repel(aes(label = y, hjust=just), size=freq.size, position=position_dodge(width = 0.9))
        else ggp <- ggp + ggrepel::geom_text_repel(aes(label = y, vjust=just), size=freq.size, position=position_dodge(width = 0.9))
      }
      
      if(stat.test){
        testres <- chisq.test(table(dat))
        stat.test.name <- "Pearson's chi-squared test"
        if(any(testres$expected<5)){
          testres <- fisher.test(table(dat))
          stat.test.name <- "Fisher's exact test"
        }
        labp <- ifelse(testres$p.value<0.0001, "<0.0001", paste0("=",sprintf("%.4f", round(testres$p.value,4))))
        labtest <- paste0(stat.test.name,", p",labp)
        
        if(!is.null(stat.test.size)) stat.test.size <- stat.test.size * 0.3514598
        else stat.test.size <- 10 * 0.3514598
        
        if(is.null(stat.test.pos)){
          candx <- 1.2
          candy <- max(ggplot_build(ggp)$data[[1]]$y) * 1.1
          statdatpos <- data.frame(x=candx, y=candy)
        }
        else statdatpos <- data.frame(x=stat.test.pos[1], y=stat.test.pos[2])
        
        ggp <- ggp + ggrepel::geom_text_repel(aes(x=x, y=y), data=statdatpos, label = labtest, size=stat.test.size, inherit.aes = F, point.padding = NA, min.segment.length=10000)
      }
    }
    if(type=="facet"){
      labelv <- NULL
      if(label){
        labelv <- paste0(by," = ",levels(dat$group))
        names(labelv) <- levels(dat$group)
      }
      
      dat2$just <- as.integer(freq.pos.top)
      dat2$just[dat2$y==0] <- 1
      ggp <- ggplot(aes(x, y, fill=group), data=dat2) + geom_col(color="black", na.rm=T) + geom_hline(yintercept = 0) + 
        facet_wrap(~group, ncol=1, scales="fixed", labeller = labeller(group=labelv))
      if(freq.info){
        if(flip) ggp <- ggp + ggrepel::geom_text_repel(aes(label = y, hjust=just), size=freq.size)
        else ggp <- ggp + ggrepel::geom_text_repel(aes(label = y, vjust=just), size=freq.size)
      }
      ggp <- ggp + theme(legend.position = "none")
    }
    ggp <- ggp + guides(color = guide_legend(by), fill = guide_legend(by))
    if(!is.null(color.group)) ggp <- ggp + scale_fill_manual(values=color.group)
  }
  
  if(!is.null(ext.hline)){
    ext.hline.dat <- list()
    for(j in 1:length(ext.hline)){
      ext.hline.dat[[j]] <- data.frame(yintercept=as.numeric(strsplit(ext.hline[[j]][1],",")[[1]]),
                                       linetype=as.numeric(ext.hline[[j]][2]), size=as.numeric(ext.hline[[j]][3]), color=ext.hline[[j]][4])
    }
    ext.hline.dat <- do.call(rbind, ext.hline.dat)
    ggp <- ggp + geom_hline(aes(yintercept = yintercept), ext.hline.dat, color=ext.hline.dat$color, linetype=ext.hline.dat$linetype, size=ext.hline.dat$size)
  } 
  
  if(!is.null(tick_y)) ggp <- ggp + scale_y_continuous(breaks=as.numeric(names(tick_y)), labels = as.character(tick_y))
  
  if(flip==TRUE) ggp <- ggp + coord_flip(ylim=ylim, expand=lim.expand)
  else ggp <- ggp + coord_cartesian(ylim=ylim, expand=lim.expand)
  
  return(ggp + labs(list(title=title, x=xlab, y=ylab)) + theme_opt)
}

#####Circle plot

REx_circleplot <- function(varname, dataset, showCount="C", title=varname, 
                           freq.size=NULL, title.size=NULL, color.group=NULL,
                           lgd.pos="right", lgd.back=F, lgd.title=NULL, lgd.text=NULL){
  load.pkg(c("ggplot2", "ggpubr", "ggrepel"))

  if(lgd.back) lgd.back2 <- NULL
  else lgd.back2 <- element_rect()
  
  theme_opt <- theme(plot.title = element_text(hjust = 0.5, size = title.size),
                     legend.position = lgd.pos, legend.background = lgd.back2, 
                     legend.title = element_text(size = lgd.title), legend.text = element_text(size = lgd.text))
  
  x <- factor(dataset[,varname])
  dat <- data.frame(table(x))
  if(sum(is.na(x))>0) dat <- rbind(dat, data.frame(x="NA", Freq=sum(is.na(x))))
  colnames(dat)[1] <- varname
  dat$Perc <- paste0(round(dat$Freq/length(x)*100,1), "%")
  dat$Both <- paste0(dat$Freq, " (", dat$Perc, ")")
  
  lev <- levels(x)
  if(sum(is.na(x))>0) lev <- c(lev, "NA")
  if(is.null(color.group)) color.group <- gg_color_hue2(length(lev))
  
  if(showCount=="C") labs <- dat$Freq
  if(showCount=="P") labs <- dat$Perc
  if(showCount=="CP") labs <- dat$Both
  if(showCount=="N") labs <- rep("", nrow(dat))
  labs <- rev(labs)
  
  if(is.null(color.group)) color.group <- gg_color_hue2(nrow(dat))
  if(is.null(freq.size)) freq.size <- 10 * 0.3514598
  else freq.size <- freq.size * 0.3514598
  
  ggpie2 <- ggpie
  body(ggpie2)[[10]] <- substitute(
    p <- ggpar(p, palette = palette, ggtheme = ggtheme, font.family = font.family, 
               ...) + coord_polar(theta = "y", start = pi/2) + ggtheme + 
      .remove_axis()
  )
  body(ggpie2)[[11]][[3]][[3]][[3]][[2]] <- substitute(
    p <- p + ggrepel::geom_text_repel(aes_string(y = ".lab.ypos.", x=1.1, label = label), point.padding = NA,
                                      size = lab.font$size, fontface = lab.font$face, colour = "black", 
                                      family = font.family) + clean_theme()
  )
  
  ggp <- ggpie2(dat, "Freq", label=labs, fill=varname, palette=color.group, lab.pos = "in", lab.font = list(size=freq.size)) + 
    guides(fill = guide_legend(varname)) + labs(title=title) + theme_opt
  
  return(ggp)
}

### Get comb of group variables from XY Plot
xyplot_color.group <- function(dataset, by){
  dat3 <- dataset[by]
  for(i2 in 1:ncol(dat3)){
    dat3[,i2] <- factor(dat3[,i2])
    if(sum(is.na(dat3[,i2]))>0) dat3 <- dat3[-which(is.na(dat3[,i2])),]
  }
  group <- levels(interaction(dat3[,by]))
  return(paste(group, collapse=","))
}

### Get comb of var levels from Circle Plot
circleplot_color.group <- function(dataset, varname){
  x <- factor(dataset[,varname])
  lev <- levels(x)
  if(sum(is.na(x))>0) lev <- c(lev, "NA")
  return(paste(lev, collapse=","))
}

### Default group color
gg_color_hue <- function(n) {
  hues = seq(6.330885, 6.330885+360, length = n + 1)
  paste(hcl(h = hues, l = 51.19696, c = 144.4467)[1:n], collapse=",")
}

### Using Analysis modules...
gg_color_hue2 <- function(n) {
  hues = seq(6.330885, 6.330885+360, length = n + 1)
  hcl(h = hues, l = 51.19696, c = 144.4467)[1:n]
}

### Get Factor Levels
manual_color.group <- function(dataset, by){
  dat3 <- factor(dataset[,by])
  return(paste(levels(dat3), collapse=","))
}

### Testfunc
testfunc <- function() {
	list(a=rnorm(100), b=c("aa","bbb","ccccc",
	"dddd"))
}

#####StemLeaf plot for REx_DESCSTAT

REx_stemleaf <- function(dat, title){
  load.pkg("ggplot2")
  res <- capture.output(stem(dat))
  stemdf = data.frame(res, rr=length(res):1)
  pp <- ggplot(stemdf)+ geom_text(aes(y=rr, x=0, label=res), vjust=0, hjust=0, family="mono", size=5) + 
    theme_classic() +
    labs(list(title=title)) + 
    scale_x_continuous(limits=c(0,1))+ 
    theme(axis.text = element_blank(),
          axis.title = element_blank(), 
          axis.ticks=element_blank(), 
          panel.grid=element_blank(), 
          axis.line=element_blank(),
          plot.title = element_text(hjust = 0.5))
  return(pp)
}

#####Diagnostic plot for proportional hazards assumption in REx_Coxph

REx_coxzphplot <- function (fit, resid = TRUE, se = TRUE, df = 4, nsmo = 40,  var, 
          point.col = "red", point.size = 1.5, point.shape = 19, point.alpha = 1, 
          caption = NULL, ggtheme = theme_bw(), ...){
  x <- fit
  if (!methods::is(x, "cox.zph")) 
    stop("Can't handle an object of class ", class(x))
  xx <- x$x
  yy <- x$y
  d <- nrow(yy)
  df <- max(df)
  nvar <- ncol(yy)
  pred.x <- seq(from = min(xx), to = max(xx), length = nsmo)
  temp <- c(pred.x, xx)
  lmat <- splines::ns(temp, df = df, intercept = TRUE)
  pmat <- lmat[1:nsmo, ]
  xmat <- lmat[-(1:nsmo), ]
  qmat <- qr(xmat)
  if (qmat$rank < df) 
    stop("Spline fit is singular, try a smaller degrees of freedom")
  if (se) {
    bk <- backsolve(qmat$qr[1:df, 1:df], diag(df))
    xtx <- bk %*% t(bk)
    seval <- d * ((pmat %*% xtx) * pmat) %*% rep(1, df)
  }
  ylab <- paste("Beta(t) for", dimnames(yy)[[2]])
  if (missing(var)) 
    var <- 1:nvar
  else {
    if (is.character(var)) 
      var <- match(var, dimnames(yy)[[2]])
    if (any(is.na(var)) || max(var) > nvar || min(var) < 
        1) 
      stop("Invalid variable requested")
  }
  if (x$transform == "log") {
    xx <- exp(xx)
    pred.x <- exp(pred.x)
  }
  else if (x$transform != "identity") {
    xtime <- as.numeric(dimnames(yy)[[1]])
    indx <- !duplicated(xx)
    apr1 <- approx(xx[indx], xtime[indx], seq(min(xx), max(xx), 
                                              length = 17)[2 * (1:8)])
    temp <- signif(apr1$y, 2)
    apr2 <- approx(xtime[indx], xx[indx], temp)
    xaxisval <- apr2$y
    xaxislab <- rep("", 8)
    for (i in 1:8) xaxislab[i] <- format(temp[i])
  }
  plots <- list()
  plots <- lapply(var, function(i) {
    invisible(pval <- round(x$table[i, 3], 4))
    gplot <- ggplot() + labs(title = paste0("Schoenfeld Individual Test: p = ", 
                                            pval)) + ggtheme + theme(panel.grid.minor=element_blank())
    y <- yy[, i]
    yhat <- as.vector(pmat %*% qr.coef(qmat, y))
    if (resid) 
      yr <- range(yhat, y)
    else yr <- range(yhat)
    if (se) {
      temp <- as.vector(2 * sqrt(x$var[i, i] * seval))
      yup <- yhat + temp
      ylow <- yhat - temp
      yr <- range(yr, yup, ylow)
    }
    if (x$transform == "identity") {
      gplot <- gplot + geom_line(aes(x = pred.x, y = yhat), color="red", size=1) + 
        xlab("Time") + ylab(ylab[i]) + ylim(yr)
    }
    else if (x$transform == "log") {
      gplot <- gplot + geom_line(aes(x = log(pred.x), y = yhat), color="red", size=1) + 
        xlab("Time") + ylab(ylab[i]) + ylim(yr)
    }
    else {
      gplot <- gplot + geom_line(aes(x = pred.x, y = yhat), color="red", size=1) + 
        xlab("Time") + ylab(ylab[i]) + scale_x_continuous(breaks = xaxisval, 
                                                          labels = xaxislab) + ylim(yr)
    }
    if (resid) 
      gplot <- gplot + geom_point(aes(x = xx, y = y), col = point.col, 
                                  shape = point.shape, size = point.size, alpha = point.alpha)
    if (se) {
      gplot <- gplot + geom_line(aes(x = pred.x, y = yup), 
                                 lty = "dashed", color="red") + geom_line(aes(x = pred.x, y = ylow), 
                                                             lty = "dashed", color="red")
    }
    ggpubr::ggpar(gplot, ...)
  })
  return(plots)
}

#####Scatter Matrix for REx_CORR
REx_corrplot1 <- function(data, textweight, signifstar, Method, Test.side, exact, continuity){
  load.pkg(c("ggplot2", "GGally", "ggrepel", "scales"))
  
  ellipse_base <- function(rho, length = 1000) {
    k <- seq(0, 2 * pi, length = length)
    x <- cos(k + acos(rho)/2)
    y <- cos(k - acos(rho)/2)
    return(data.frame(x,y))
  }
  
  ellipse_func <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    very <- as.character(mapping$y)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    very2 <- ifelse(length(very)==1, very, very[2])
    cc <- cor(data[,c(verx2, very2)], use="na.or.complete", method=Method)[1,2]
    if(cc>=0) cc2 <- sqrt(cc)
    else cc2 <- -1*sqrt(-cc)
    
    ggtmp <- ggplot(data=data.frame(x=0:2, y=0:2, c=c(-1,1,cc2))) + geom_point(aes(x=x,y=y,color=c)) + scale_color_gradient2(low="#ED1D4E", high="#003CBD")
    ell_color <- ggplot_build(ggtmp)$data[[1]]$colour[3]
    
    ggplot(data=ellipse_base(rho=cc), aes(x=x,y=y)) + geom_polygon(fill=ell_color)
  }
  
  corcoef_func <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    very <- as.character(mapping$y)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    very2 <- ifelse(length(very)==1, very, very[2])
    cc <- cor(data[,c(verx2, very2)], use="na.or.complete", method=Method)[1,2]
    if(cc>=0) cci <- sqrt(cc)
    else cci <- -1*sqrt(-cc)
    
    cc2 <- exp(abs(cc)*2)
    cc2 <- ifelse(textweight, exp(abs(cc)*2), 3.88)
    
    cp <- cor.test(as.formula(paste0("~",verx2,"+",very2)), data, 
                   alternative = Test.side, method = Method, exact = exact, continuity = continuity)$p.value
    cp2 <- ifelse(cp<0.001, "***", ifelse(cp<0.01, "**", ifelse(cp<0.05, "*", ifelse(cp<0.1, ".", ""))))
    cp2 <- ifelse(signifstar, cp2, "")
    
    
    ggtmp <- ggplot(data=data.frame(x=0:2, y=0:2, c=c(-1,1,cci))) + geom_point(aes(x=x,y=y,color=c)) + scale_color_gradient2(low="#ED1D4E", high="#003CBD")
    ell_color <- ggplot_build(ggtmp)$data[[1]]$colour[3]
    
    # ggplot() + geom_text(aes(x=0, y=0), label=round(cc,3), color=ell_color)
    ggplot(data=data.frame(x=0:1, y=0:1, lab=c(round(cc,3),cp2))) + ggrepel::geom_text_repel(aes(x=x,y=y,label=lab), color=c("black", "#ED1D4E"), size=c(cc2, 7), point.padding = NA) + 
      coord_cartesian(xlim=c(-1,1), ylim=c(-1,1))
  }
  
  varname_func <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    
    ggplot() + geom_text(aes(x=0, y=0), label=verx2)
  }
  
  ggtmp <- ggplot(data=data.frame(x=0:200, y=0:200, c=c(-1*sqrt(seq(1,0,-0.01)), sqrt(seq(0.01,1,0.01))))) + 
    geom_point(aes(x=x,y=y,color=c)) + scale_color_gradient2(low="#ED1D4E", high="#003CBD") + theme_bw()
  gg_leg <- ggplot(data=data.frame(x=0:200, y=0:200, c=seq(-1,1,0.01))) + geom_point(aes(x=x,y=y,color=c)) + 
    scale_color_gradientn(colors=ggplot_build(ggtmp)$data[[1]]$colour, values = rescale(seq(-1,1,0.01))) +
    guides(color = guide_colorbar(title=element_blank(), barwidth = 20, barheight = 0.5, frame.colour = "black")) + 
    theme_bw() + theme(legend.position = "bottom")
  gg_leg <- grab_legend(gg_leg)
  
  gg_temp <- ggpairs(data=data, lower=list(continuous=ellipse_func), upper=list(continuous=corcoef_func), diag=list(continuous=varname_func), axisLabels = "n", legend = gg_leg)
  gg_final <- gg_temp + theme_bw() + theme(panel.spacing=grid::unit(0,"lines"), panel.grid = element_blank(), 
                                           strip.background = element_blank(), strip.text = element_blank(),
                                           panel.border = element_rect(color="grey"), legend.position = "bottom")
  return(gg_final)
}

REx_corrplot2 <- function(data, textweight, signifstar, Method, Test.side, exact, continuity){
  load.pkg(c("ggplot2", "GGally", "ggrepel"))
  
  point_func2 <- function(data, mapping, ...){
    ggplot(data=data, mapping=mapping) + geom_point() +
      geom_smooth(method = "loess", se=F, level = 0.95, color="#ED1D4E", fill="#ED1D4E", size=0.75)
  }
  
  diag_func <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    
    ggp1 <- ggplot(data=data, mapping=mapping) + geom_histogram(bins=10, fill="grey", color="black") 
    ggp2 <- ggplot(data=data, mapping=mapping) + geom_density(color="#ED1D4E")
    xlim1 <- layer_scales(ggp1)$x$range$range
    ylim1 <- layer_scales(ggp1)$y$range$range
    ggpdata2 <- ggplot_build(ggp2)$data[[1]]
    ggpdata2$y <- ggpdata2$y*(ylim1[2]*0.9/max(ggpdata2$y))
    ggp1 + geom_rug() + geom_hline(yintercept = 0) + geom_line(aes(x=x, y=y), data=ggpdata2, color="#ED1D4E", inherit.aes = F) +
      ggrepel::geom_text_repel(aes(x=x, y=y), data=data.frame(x=mean(xlim1), y=ylim1[2]), label=verx2, size=5, inherit.aes = F)
  }
  
  corcoef_func2 <- function(data, mapping, ...){
    verx <- as.character(mapping$x)
    very <- as.character(mapping$y)
    verx2 <- ifelse(length(verx)==1, verx, verx[2])
    very2 <- ifelse(length(very)==1, very, very[2])
    
    cc <- cor(data[,c(verx2, very2)], use="na.or.complete", method=Method)[1,2]
    cc2 <- exp(abs(cc)*2)
    cc2 <- ifelse(textweight, exp(abs(cc)*2), 3.88)
    
    cp <- cor.test(as.formula(paste0("~",verx2,"+",very2)), data, 
                   alternative = Test.side, method = Method, exact = exact, continuity = continuity)$p.value
    cp2 <- ifelse(cp<0.001, "***", ifelse(cp<0.01, "**", ifelse(cp<0.05, "*", ifelse(cp<0.1, ".", ""))))
    cp2 <- ifelse(signifstar, cp2, "")
    
    ggplot(data=data.frame(x=0:1, y=0:1, lab=c(round(cc,3),cp2))) + ggrepel::geom_text_repel(aes(x=x,y=y,label=lab), color=c("black", "#ED1D4E"), size=c(cc2, 7), point.padding = NA) + 
      coord_cartesian(xlim=c(-1,1), ylim=c(-1,1))
  }
  
  gg_final <- ggpairs(data=data, lower=list(continuous=point_func2), upper=list(continuous=corcoef_func2), diag=list(continuous=diag_func)) + 
    theme_bw() + theme(panel.spacing=grid::unit(0,"lines"), panel.grid = element_blank(), 
                       strip.background = element_blank(), strip.text = element_blank(),
                       panel.border = element_rect(color="grey"))
  return(gg_final)
}

#####Multiplot func for REx_DESCSTAT

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  load.pkg("grid")
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

